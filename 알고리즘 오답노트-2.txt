2021-07-22
SCPC-3 예선-2 5번
n개의 막대기가 주어진다. 막대기들은 직선상의 구간 [a, b]로 나타낸다. 각 막대는 wi의 전류가 흐르면 자석이 되고, 그 자석과 구간이 겹치는 막대기는 자석에 달라붙게 된다. 모든 막대가 자석이 되거나, 자석에 붙은 상태가 되도록 만드는 최소 전류 합을 구해야 한다. 세그먼트 트리를 이용한 dp로 문제를 해결할 수 있다. 내가 문제를 푼 방식은 이렇다. dp(i)를 지금까지 본 막대들이 모두 cover되고, 마지막으로 켠 막대가 i에서 끝날 때 들어간 최소 비용으로 정의한다. 그리고 dp2(i)를 i좌표까지 모두 cover 됐을 때 드는 최소 비용으로 정의한다. 그 후 막대들을 y순, x역순으로 보면서 dp와 dp2값들을 유지하면 dp2(mx-1)에 우리가 원하는 답이 저장된다. 이 때, 주의할 점은 dp값에서 지금까지의 막대 중 x 최대값 미만 좌표들은 모두 무효로 만들어야한다. kdh의 풀이는 조금 더 간단한 것 같다. 전력이 들어가지 않은 두 막대기 [a, b], [c, d]에 대해 a <= c <= d <= b라면 [a, b]가 자석에 붙었는지에 대한 여부는 신경쓰지 않아도 된다. [c, d]가 자석에 붙었다면 [a, b]도 자석에 붙게 되기 때문이다. 따라서 다른 막대를 완전히 포함하는 막대들은 제거해줄 수있다. 단, 전력을 넣어 자석으로 만드는 경우는 제거된 막대들도 고려해야한다. 남은 막대기들을 시작점이 증가하는 순으로 정렬하면 끝점 역시 증가하게 된다. 이 상태에서 한 막대기를 자석으로 만들었을 때, 자석에 붙는 막대기의 집합은 항상 구간으로 나타나게 된다. 따라서 dp(i)를 1~i번 막대기를 커버하는 최소비용으로 정의하면 세그먼트 트리로 O(nlogn)에 문제를 해결할 수 있다.

2021-07-23
https://www.acmicpc.net/problem/15022
n개의 팀이 문제를 푼다. 총 m개의 이벤트가 발생하는데, 각 이벤트는 t번 팀이 p의 페널티로 1 문제를 더 풀었음을 의미한다(n,m은 최대 10만). 각 이벤트 이후 1번 팀의 등수를 출력해야 한다. 두 팀의 점수를 비교할 때는 푼 문제 수가 높은 쪽이 점수가 높으며, 푼 문제수가 같을 경우 페널티가 작은 쪽이 점수가 높다. 1번 팀의 등수는 1번 팀보다 더 높은 점수를 가진 팀의 개수 + 1의 값이다. 1번 팀보다 높은 점수를 가지는 팀의 집합 S를 계속 유지해주면 된다. 1번 팀이 문제를 하나 더 풀었을 경우, S에서 1번보다 낮거나 같은 점수를 가진 팀들을 제거하고, 다른 팀이 문제를 하나 더 풀었을 경우 S를 그에 맞춰 갱신해주면 된다. 1팀을 추가 및 삭제하는 데에는 O(logN)이 걸린다. S의 추가 연산 횟수는 이벤트 당 최대 1이므로 O(M)번의 추가 연산이 발생하며, S 안에 들어있는 팀에 대해서만 삭제 연산이 수행하므로 삭제 연산 횟수 역시 O(M)번이다. 따라서 총 시간 복잡도는 O(MlogN)이다.

https://www.acmicpc.net/problem/15020
n*m 격자칸이 주어진다(n,m은 최대 500). 각 격자칸에는 그 칸에 해당하는 위치의 해발고도가 적혀 있다. 해발고도가 음수일 경우, 그 곳에는 그만큼 바닷물이 차있다. (i, j) 좌표의 바닥에 배수 장치를 설치한다. (i, j)의 고도 값은 음수임이 보장된다. 배수 장치를 작동시켰을 때, 총 흡수하는 바닷물의 양을 계산해야한다. 한 좌표 칸에 해당하는 흡수량은 인접한 칸들 중 가장 흡수량이 많은 것에 의해서만 결정된다. 따라서 흡수량의 비오름차순으로 탐색한다면 중복 방문 없이 모든 격자으로부터의 흡수량을 계산해줄 수 있다. 이를 위해서는 다익스트라와 유사하게 우선순위큐를 사용해주면 된다. 총 시간 복잡도는 O(n*m log(n*m))이다.

https://codeforces.com/contest/1553/problem/F
최대 20만인 n 크기의 배열이 주어진다. 각 원소의 값은 1 이상 30만 이하의 값이며, 원소 값은 모두 다르다. 값의 범위 크기를 m이라고 두자. i번째 원소 값을 arr(i)라고 했을 때, p(k)는 sum(1<=i,j<=k){ ai mod aj } 이다. p(1), p(2), ..., p(n)의 값을 각각 출력해야한다. x mod y 는 x - y * floor(x/y)로 바꿔줄 수 있다. floor(x/y)는 x를 y로 나눈 몫에 해당한다. p(k)를 s(k) = sum(1<=i,j<=k and i>j), t(k) = sum(1<=i,j<=k and i<j)로 분리해서 계산해보자. s(k) = s(k-1) + sum(j=1~k-1){ a(k) mod a(j) } 인데, 위에 사용한 식을 이용하여 sum(j=1~k-1){ a(k) mod a(j) } 부분을 a(k) * (k-1) - sum(j=1~k-1){ a(j) * floor(a(k)/a(j)) }로 바꿔줄 수 있다. sum(j=1~k-1){ a(j) * floor(a(k)/a(j)) }를 빠르게 구하기 위해서는 구간 업데이트, 점 쿼리를 O(logm)만에 수행할 수 있는 세그먼트 트리가 사용된다. s(k)를 하나씩 계산하면서, s(k)의 계산이 끝나면 a(k)를 가지고 이후에 필요한 값들을 update 해준다. 이후의 인덱스에서 원소 값이 [a(k)*i, a(k)*(i+1)) 구간에 해당한다면 mod a(k)의 값을 계산할 때 a(k)*i의 값을 빼줘야한다. 따라서 i를 1부터 1씩 증가시켜가며 [a(k)*i, a(k)*(i+1)) 구간에 a(k)*i 값을 더해주면 나중에 각 인덱스에서 빼줘야하는 값을 O(logm)만에 계산할 수 있다. update 연산이 굉장히 많아질 수 있는데, 모든 원소 값은 서로 다르기 때문에 update 횟수는 m/1 + m/2 + ... + m/n이 되어 최종적으로 O(mlogn)번이 된다. 따라서 총 시간복잡도 O(m logm logn)만에 s(k)를 모두 계산해낼 수 있다. t(k) 또한 비슷한 방법으로 구할 수 있다. 단, t(k)를 구할 때는 점 업데이트, 구간 쿼리를 O(logm)만에 수행하는 세그먼트 트리가 사용된다.

2021-07-24
SCPC-3 예선-2 3번
최대 10만인 n개의 자연수가 주어진다. 자연수의 값은 1 이상 100만 이하이다. m개의 질의가 주어진다. 각 질의는 b, l, r로 이루어져있다. 질의의 의미는 b의 모든 약수들 중 a[l], ..., a[r]의 값들을 하나도 나누어 떨어트리지 못하는 것의 개수를 묻는 것이다. 모든 질의의 답을 계산하여 더한 값을 출력해야 한다. 처음에는 소인수 분해를 해야하는 문제인 줄 알았다. 그런데 소인수들만으로는 질의의 답을 계산해낼 수 없었다. 결국 각 숫자마다 약수들을 구해야한다고 생각했다. 내 풀이는 이렇다. pos[i]이 i로 나누어 떨어지는 숫자들이 a 수열 상에 위치한 인덱스 목록을 저장한다. a 수열을 처음부터 하나씩 보면서 모든 약수를 O(sqrt(MX))만에 구한 후, 약수마다 pos[idx]에 현재 인덱스 값을 넣어주면 된다. 그 후 쿼리를 하나씩 처리한다. b의 약수를 모두 구한 후, pos[div]에서 l보다 크거나 같은 값이 위치한 인덱스를 찾는다. 그러한 인덱스가 없거나 그 인덱스에 위치한 값이 r보다 클 경우, [l, r] 구간 내에 현재 약수로 나누어 떨어지는 수가 없다는 뜻이므로 ans를 1 증가시켜준다. 이렇게 답을 구하게 되면 총 시간 복잡도가 O(sqrt(MX) M logN)이 나온다. kdh는 오프라인 쿼리로 문제를 해결했다. 오프라인 쿼리를 사용하면 logN을 제거해줄 수 있다. 먼저 1~MX 숫자들의 약수 목록을 전처리 과정에서 구해준다. 현재 고려중인 약수 i를 1부터 MX까지 1씩 증가시키고, i를 약수로 가지는 숫자 j를 i부터 MX까지 i씩 증가시키면 MX개 숫자들의 모든 약수 목록을 빠르게 계산해낼 수 있다. 총 연산 횟수는 MX/1 + MX/2 + ... + MX/MX가 된다. MX를 묶어냈을 때, MX * (1/1 + 1/2 + ... + 1/MX)의 형태가 되는데 괄호 안의 값은 조화 수열이므로 총 시간 복잡도 및 공간 복잡도는 O(MX logMX)가 된다. 쿼리의 답을 구하기 전에 쿼리를 미리 저장한다. 그리고 수열의 값을 하나씩 보면서 last[i]를 계산한다. last[i]의 의미는 i의 배수가 등장한 마지막 위치를 의미한다. 만약 현재 수열의 위치를 끝점으로 하는 쿼리가 있을 경우 쿼리의 답을 계산한다. b의 약수 div에 대해 last[div]의 값이 l보다 작다면 [l, r]구간 내에 div로 나누어 떨어지는 수가 존재하지 않는다. 이를 O(1)만에 판단하므로 총 시간 복잡도는 O(N * 약수 개수의 최대값 + MXlogMX)가 된다.

2021-07-26
SCPC-3 예선-2 4번
n개의 정점으로 구성된 트리 그래프가 주어진다. 임의의 p개의 정점 집합 I로 연결된 그래프 G를 만들었을 때, I에 포함되지 않은 정점과 그래프 G 사이의 거리 중 최대값을 최소화 해야 한다. 문제를 풀기 위해 그리디 방식으로 접근해봤다. n개 정점을 모두 I에 넣어두고 하나씩 제거해나간다고 하자. dist(x)를 x 정점과 그래프 G 사이의 거리라고 하자. 이 때, 제거하는 정점은 현재 그래프 G의 리프 정점들 중 해당 정점을 제거했을 때 갱신되는 dist(x)의 새로운 값들 중 최대값이 가장 작은 걸 제거하면 된다. 간선의 삭제를 빠르게 수행하기 위해 set을 이용하여 그래프를 구현해야한다. 남은 정점 중 제거할 정점을 빠르게 찾기 위해서는 우선순위 큐를 이용한다. 우선순위 큐에 들어가는 노드들은 위에서 설명한 값의 역순으로 정렬된다. 문제를 풀기 위해서 maxv(x) 배열이 사용된다. maxv(x)는 x에서 I에 포함되지 않는 정점만을 경유해서 도달할 수 있는 가장 먼 정점까지의 거리이다. I에서 정점을 삭제할 때마다 이 배열을 갱신해줘야 하는데, 정점을 삭제할 때 인접한 정점의 maxv를 삭제되는 (정점의 maxv) + (간선의 가중치) 값을 가지고 최대값 연산을 하면 O(1)만에 갱신 할 수 있다.

2021-07-28
SCPC-3-본선 2번
2개의 볼록 다각형 A, B가 주어진다. 각각의 볼록 다각형 내에 한 점을 정했을 때, 두 점 사이의 최단 거리를 구해야한다. 문제를 풀기 위해서 A의 1번 꼭지점에서 가장 가까운 B의 선분을 찾는다. 그 후 A의 2번 꼭지점부터는 이전에 골랐던 B의 선분에서 이웃한 선분으로 이동하며 가장 가까운 선분을 찾으면 된다. 이후 A와 B를 바꿔서 B의 각 꼭지점에서 가장 가까운 A의 선분을 찾는다. 이와 같이 계산한 거리 값들 중 최소값이 우리가 구하고자 하는 답이 된다. 처음에는 수선의 발을 구하기 위해서 삼분탐색을 사용했다. 공식이 기억나지 않아서였는데, 시간초과로 인해 부분 점수밖에 받지 못 했다. 라이브러리에서 수선의 발을 구하는 공식을 복사해 O(1)만에 수선의 발을 계산했더니 만점을 받았다.

https://www.acmicpc.net/problem/15334
다익스트라 연습 문제. 방향이 있는 그래프가 주어진다. 처음에는 1번에서 2번으로 가는 경로가 반드시 존재한다. 다음날부터 길의 방향이 하나씩 정반대로 바뀌었다가 원래대로 돌아간다. 각 간선의 방향이 바뀌었을 때, 1번에서 2번으로 가는 최단 경로가 더 짧아졌다면 HAPPY, 더 길어졌다면 SAD, 변함없다면 SOSO를 출력해야한다. 다익스트라를 이용하면 문제를 해결할 수 있다. 1번에서 2번으로 가는 최단 경로에 포함된 간선의 방향이 바뀌었을 때, 해당 간선이 bridge라면, 다시 말해 2번으로 최단 거리로 가려면 반드시 해당 간선을 거쳐야 한다면 답은 SAD이다. 왜냐하면 방향이 뒤집혀서, 뒤집힌 간선으로 더 빠르게 혹은 같은 거리 값으로 2번으로 도달할 수 있었다면 해당 간선은 애초에 최단 경로에 포함되지 않았을 것이다. 해당 간선이 bridge가 아니라면 최단 경로가 더 짧아질 일은 없으므로 답은 SOSO이다. 이제 간선이 2번으로 가는 최단 경로에 사용되지 않았을 경우를 생각해보자. 최단 경로에 사용되지 않았으므로 최단 경로가 길어졌을리는 없고, 뒤집힌 간선으로 인해 더 짧은 경로가 생겼는지 확인해주면 된다. 이를 위해서는 모든 간선이 뒤집힌 역방향 그래프에서, 2번 정점에서 모든 정점으로의 최단 거리값이 필요하다. 원래 그래프의 1번에서 i번 정점까지의 거리를 distf(i)라고 하고, 역방향 그래프의 2번에서 i번 정점까지의 거리를 distr(i)라고 하자. 그러면 현재 간선을 u에서 v로 가는 w 가중치를 가진 간선이라고 했을 때, 식 distf(v) + w + distr(u) < distf(2)가 참이라면 뒤집힌 간선으로 최단 경로가 짧아진 것이므로 HAPPY를 출력하고, 그렇지 않다면 SOSO를 출력하면 된다. 1번에서 2번으로 가는 최단 경로에 현재 간선이 사용되는지 확인하기 위해서는, 마찬가지로 distf와 distr을 사용하면 된다. distf(u) + w + distr(v)가 distf(2)와 같다면, 현재 간선은 2번으로 가는 최단 경로에 사용되는 간선이다. 최단 경로에 사용된 간선이 bridge인지 판단하기 위해서는, BCC에 사용된 단절선 개념을 가져오면 된다. BCC 알고리즘은 무방향 그래프에서 단절점과 단절선을 찾기 위해 사용되는 알고리즘이다. 하지만 최단 경로에 사용되는 간선들은 DAG이므로, 해당 간선들만 모아서 그래프를 만들고 방향을 없앴을 때 생기는 단절선은 원래 그래프의 bridge와 일치하기 때문에 문제 없이 동작한다.

2021-07-29
SCPC-3-본선 3번
1번 우주선과 2번 우주선이 순간이동을 하며 colony를 건설하려고 한다. 각 우주선은 매 1년이 시작되는 1월 1일에 특정 위치로 가서 1년 동안 머무르며 colony를 건설한다. 각 우주선의 경로는 입력으로 주어지며, 최대 10만개이다. 1번 우주선에서 2번 우주선으로 메시지를 보내려고 한다. (a, b)에서 (c, d)로 메시지를 보내는 데 걸리는 시간은 abs(a-c) + abs(b-d)년이다. 이미 지어진 2번 우주선의 식민지로 보낼 수도 있고, 2번 우주선이 올 예정인 곳에 미리 보내놓을 수도 있다. 단, 미리 보내는 경우, 2번 우주선이 그곳에 도착한 시점이 메시지 전달에 성공한 시점이 된다. 이 때, 2번에게 가장 빨리 메시지를 전달할 수 있는 연도를 계산해야 한다. 문제를 온전히 이해하지 못하여, 2번 우주선이 도착할 좌표에 미리 보내는 경우 그 좌표에 메시지가 도착한 시점을 메시지 전달 성공 시점으로 계산했다. 하지만 이게 아니더라도 TLE가 발생해 만점을 받긴 힘들었다. 그래도 얻어가는 건 있었다. 만점을 받기 위해서는 plane sweeping을 사용해야했다. 그런데 메시지를 보내는 데 걸리는 시간을 x좌표 차이와 y좌표 차이의 합으로 계산하기 때문에, 거리가 d 이하인 구간은 45도 기울어진 정사각형의 모양으로 나타나므로 좌표평면을 45도 회전시켜야 한다.  기하에 쓰이는 함수들을 사용하면 점을 원점 기준으로 45도 회전시키는 것은 어렵지 않다. 하지만 좌표 압축이 필요하므로 회전 후 좌표를 모두 정수로 나타내고 싶었다. 방법은 어렵지 않았다. 회전 후 모든 좌표를 sqrt(2)로 나누면 모두 정수가 된다. 이를 빠르게, 오차 없이 계산하려면, 변환 전 좌표를 (x, y)라고 하고 변환 후 좌표를 (nx, ny)라고 했을 때, nx = x - y, ny = x + y가 된다. 

시간초과를 해결하기 위해 조금 커팅을 시도해봤다. 현재 내 풀이는 세그먼트 트리에 이진탐색을 섞은 풀이인데, 이진 탐색 중간에 탐색 범위를 봤을 때 현재 구해놓은 답보다 좋을 수가 없는 경우 아무 값이나 반환하도록 했다. 그랬더니 5초 시간 제한 안에 돌아가지 않던 코드가 3.7초만에 모두 돌아갔다. 하지만 역시 풀이가 정확하지 않기 때문에 0점을 받았다.

2021-08-02
SCPC-4 예선-1 1번
n명의 바둑 선수가 있다. 각 선수들은 a(i)의 실력을 가진다. 실력 값은 모두 다르다. n명의 선수가 몇 대의 버스에 나누어 타려고한다. 단, 실력의 값의 차이가 k 이하인 선수 두 명은 같은 버스에 탈 수 없다. 이 때 필요한 버스 대수의 최소값을 구해야 한다. 여러 풀이가 있고 떠올리기 쉬운편이나, kdh 슬라이드 노트에 있는 O(N)의 풀이는 직접 떠올리기 어려웠을 것 같아 정리하려고 한다. 문제의 답은 |a(i) - a(j)| <= k 인 (i, j)들 중 j-i+1의 최대값이 된다. 증명은 2단계로 진행된다. 첫 번째, 답이 그 값보다 작을 수 없다. |a(i) - a(j)| <= k 인 (i, j)들 중 j-i+1가 최대인 (i, j)를 하나 잡았다고 하자. 그러면 k 범위 내에 j-i+1 개의 실력 값이 모여 있다. 버스를 j-i+1대보다 적게 준비하면, 비둘기집 원리에 의해 적어도 두 명은 같은 버스를 타야하고, 문제의 조건에 위배된다. 따라서 최소 j-i+1대가 필요하다. 두 번째, 가능한 버스 배치가 존재한다. |a(i) - a(j)| <= k 인 (i, j)들 중 j-i+1의 최대값을 m이라고 하자. m대의 버스를 준비해서 a(i)를 (i-1) % m + m번 버스에 태울 경우, 같은 버스에 탄 선수는 무조건 인덱스 차이가 m이상 나기 때문에 실력 값의 차이가 k를 초과하게 된다. 따라서 m대의 버스로 모든 선수를 태울 수 있다.

2021-08-06
SCPC-6 예선-2 3번
연속한 k(최대 200)일 동안 아르바이트를 하려고 한다. 전체 날짜 수는 n(최대 20만)이다. 아르바이트 비용이 총 Q번 바뀌는데, 바뀐 순간마다 가능한 아르바이트 비 총합 중 중앙값을 출력해야 한다. 임의의 원소 삭제가 가능한 heap 2개를 사용하면 문제를 해결할 수 있다. 다만 효율적으로 코드를 짜지 않으면 TLE를 받을 수 있다. 중앙값을 O(1)만에 찾기 위해서는 두 heap의 크기를 일정하게 유지해줘야 한다. 이 일정하게 유지해주는 작업 bal() 함수에 정의해두고, 삽입, 삭제가 일어날 때마다 수행해주었더니 subtask 2에서는 3초가 걸렸고, subtask 3에서는 6초가 넘어 TLE를 받았다. 하지만 방법을 바꾸어서 쿼리마다 k번의 삽입 삭제를 모두 해준 뒤 한번만 bal() 함수를 호출했더니 subtask 2에서는 2초가 걸렸고, subtask 3의 시간 제한도 통과하여 만점을 받았다. 최악의 경우 반복문 수행 횟수는 같지만, 양쪽 heap에 골고루 들어가게 되는 경우 수행 횟수가 0이 된다. 아마 heap의 함수를 호출하는 과정의 상수가 꽤 크기 때문에 유의미한 차이가 났던 것 같다. 상수 컷팅을 위해서는 정말 사소한 것 하나하나까지 살펴봐야한다.

2021-08-12
https://www.acmicpc.net/problem/1315
n(최대 50)개의 퀘스트가 주어진다. 플레이어는 2개의 스탯을 가지고 있는데 하나가 STR이고 다른 하나가 INT이다. i번 퀘스트를 깨기 위해서는 STR이 s(i) 이상이거나 INT가 t(i) 이상이어야 한다. 해당 퀘스트를 깰 경우 p(i)만큼의 포인트를 주고, 얻은 포인트 1점으로 STR을 1 상승시키거나 INT를 1 상승시킬 수 있다. s(i), t(i), p(i)의 값은 1000 이하의 자연수이다. 이 때, 깰 수 있는 퀘스트 개수의 최대값을 계산해야 한다. 퀘스트를 깨는 순서는 정해져 있지 않았다. 그래서 그 순서를 먼저 정한 뒤 dp를 적용하는 문제인 줄 알았다. 하지만 정렬 방법을 찾지 못 했다. 정해는 이렇다. dp(i, j)에 어떤 순서로 퀘스트를 클리어 했을 때, (STR, INT) 값이 (i, j)에 도달할 수 있는 지에 대한 boolean 값으로 지정한다. 그리고 lpnt(i, j)를 (i, j) 스탯에 도달하고, 깰 수 있는 모든 퀘스트를 깬 뒤에 남은 포인트 값으로 지정한다. 이 때, dp(i, j)가 참이 되려면 dp(i-1, j)가 참이면서 lpnt(i-1, j)가 1 이상이거나, dp(i, j-1)이 참이면서 lpnt(i, j-1)이 1 이상이면 된다. 이전 상태에 실제로 도달 했었는지는 이미 계산했으니 신경쓰지 않아도 되며, 해당 상태에서 포인트가 남아있으니 현재 상태로 전이할 수 있는 것이다. lpnt(i, j)는 퀘스트 n개를 모두 살펴보며 다시 계산해주면 된다. 이전 상태까지 포인트를 어떻게 투자했는지는 알 필요 없다. 단순히 현재 상태에 도달할 수 있다면, 남은 포인트를 O(n)만에 계산할 수 있다. s(i), t(i) 값의 범위를 MX라고 두면 dp table을 채우는데 O(MX*MX*n)의 시간이 걸린다. 각 상태마다 도달 여부를 판단하고 나면, 클리어할 수 있는 퀘스트 개수 역시 O(n)만에 판단할 수 있다. 따라서 총 시간 복잡도는 O(MX*MX*n)이다.

2021-08-18
https://www.acmicpc.net/problem/1693
n개의 정점으로 이루어진 트리가 주어진다. 각 정점을 1~n의 색상으로 색칠하려고 한다. 인접한 두 정점은 서로 다른 색깔로 칠해야하며, 한 정점을 i 색상으로 색칠하는 데에 i 비용이 들어간다. 이 때, 조건을 만족하며 모든 정점을 색칠하는 데 드는 최소 비용을 계산해야 한다. 예제를 손으로 직접 풀어보니 트리 dp의 냄새가 강하게 났다. 사용되는 색상의 개수가 매우 작다는 점을 이용하여 dp를 적용하면 될 거라고 생각했다. 하지만 그걸 증명해내지는 못 했다. 그래도 코드를 작성해서 제출해보자고 생각했고, 10개의 색상을 사용하는 코드로 AC를 받았다. 검색을 해보니 log(n)개 이하의 색상으로 문제를 풀 수 있음을 증명하는 글이 있었다. S(k)를 k개의 색을 반드시 써야만 최소 cost로 색칠할 수 있는 그래프의 정점 개수 최소값으로 둔다. S(1) = 1이고 S(2)는 2가 된다. 이 때, S(i) > 100000을 만족하는 i를 찾을 수 있다면 i-1개의 색상으로 문제를 풀 수 있음을 증명할 수 있다. 이제 S(k)를 구하기 위해 k개의 색을 써야 최소 비용으로 색칠할 수 있는 임의의 그래프를 생각해보자. k로 색칠된 정점의 인접 정점들을 봤을 때, 1, 2, 3, ..., k-1로 색칠된 정점들이 1개 이상씩 존재해야 한다. 그렇지 않다면 k로 색칠된 정점 색상을 더 저렴한 색상으로 바꿀 수 있다. 이 때, 1, 2, 3, ..., k-1로 색칠된 이웃 정점을 루트로 하는 서브트리의 크기는 S(1), S(2), ..., S(k-1) 이상이다. 따라서 S(k)는 1 + S(1) + S(2) + ... + S(k-1)보다 크거나 같다. S(1)는 1이고, S(2)는 2이므로, S(k) >= 2^(k-1)라는 식을 얻을 수 있다. 따라서 100000개의 정점을 가지는 트리는 16개의 색상으로 문제를 풀 수 있다.

SCPC-7 예선-2 2번
좌표평면 위의 점이 8개 주어진다. 이 점들을 이동시켜서 k 크기의 정팔각형을 만드려고 한다. 그 때 이동거리의 최소값을 구해야한다. 한 점의 이동 거리는 (x1, y1)에서 (x2, y2)로 이동했을 때 abs(x1 - x2) + abs(y1 - y2)로 계산되며, 각 점의 이동거리의 합이 총 이동거리가 된다. 먼저 각 점이 정팔각형의 어느 점에 해당하는지 정해줘야 한다. 경우의 수는 총 8!개이다. 이후 정팔각형을 만들어줘야하는데 각 점들은 임의의 x, y에 대해 (x, y), (x, y+k), (x+k, y+2k), (x+2k, y+2k), (x+3k, y+k), (x+3k, y), (x+2k, y-k), (x+k, y-k) 중 하나로 이동하게 된다. 이동 거리의 공식이 x좌표 차와 y 좌표 차의 합으로 계산되기 때문에, x 방향과 y 방향을 따로 계산할 수 있다. (x, y)로 이동하는 점을 (x1, y1), (x, y+k)로 이동하는 점을 (x2, y2) ... 라고 했을 때, x 방향으로 이동하는 거리 distx는 abs(x - x1) + abs(x - x2) + abs(x - (x3-k) + abs(x - (x4-2k) + abs(x - (x5-3k)) + abs(x - (x6-3k)) + abs(x - (x7-2k)) + abs(x - (x8-k))가 된다. x에 -되는 항들을 c1, c2, c3, ..., c8이라고 했을 때, x 방향으로 이동하는 거리 distx는 x가 c1, c2, ..., c8의 중간에 있을 때 최소값을 가진다. 다시 말해, c1, c2, ..., c8을 정렬했을 때 4번째와 5번째 좌표 사이에 위치해야한다. 따라서 distx의 최소값은 ci들 중 최대값 4개의 합에서 최소값 4개를 뺀 값이 된다.

SCPC-7 예선-2 3번
nxn크기의 배열이 주어졌을 때, 총을 한발 쏘려고 한다. 이 때 다이아몬드 모양으로 점수를 얻게 되는데, 중앙 칸에 적힌 값의 k배, 그 인접한 칸에 적힌 값의 k-1배, 그 인접한 칸에 적힌 값의 k-2배 ... 의 합만큼 점수를 얻게 된다. 총이 명중하는 모든 경우 중에서 얻을 수 있는 점수의 최대값을 계산해야 한다. 부분합 dp를 이용하여 O(n^2)만에 문제를 해결할 수 있다. 다이아몬드가 1칸 이동할 때마다, 이동하는 방향의 다이아몬드 반쪽 짜리가 더해지고, 반대 방향의 다이아몬드 반쪽 짜리가 빠진다. 반쪽 짜리 모양의 구간 합을 O(n^2)만에 모두 계산하기 위해서는 > 모양과 l 모양 구간합을 알아야하고, > 모양 구간합을 계산하기 위해서는 대각선 모양의 구간합을 알아야 한다. 각각의 값을 모두 저장하기 위해 10개의 O((5n)^2) 배열을 선언하면 MLE를 받으므로, 사용한 배열을 재사용할 필요가 있었다. 공간 복잡도에 5가 붙은 이유는, 과녁 밖에 총알이 명중한 경우 계산을 편하게 만들기 위해 상하좌우 패딩을 2n씩 주었기 때문이다. 여기까지 구현하고 나서도 TLE를 받았는데, 이유는 O((5n)^2) 크기 배열 전체를 초기화했기 때문이었다. 이를 최적화하기 위해서, 초기화할 때 메모리를 모두 0로 만들 필요가 없다는 점을 이용했다. 배열의 대부분은 연산 과정에서 자동으로 채워지니 초기화 할 필요가 없다. 초기화를 해야하는 곳은 O(n)개에 불과했다. 위쪽 그리고 왼쪽과 오른쪽에 O(n)개가 초기화가 필요한 부분으로 일일이 접근해서 0으로 초기화하면 시간 제한 안에 넉넉하게 들어올 수 있다.

2021-08-19
SCPC-7 예선-2 4번
200만 길이의 문자열과 k개의 패턴이 주어진다. 각 패턴이 문자열에 등장하는 횟수를 계산해야한다. 그런데 패턴과 부분 문자열의 일치 여부를 판단하는 기준이 일반 문제들과 다르다. 각 문자가 무엇인지는 중요하지 않다. 다만 동일한 알파벳이 등장한 위치가 중요했다. 예를 들어, 패턴에서 1번에 등장한 알파벳이 3번, 5번에도 등장했다면, 부분 문자열에서도 1번에 등장한 알파벳이 정확히 3번, 5번에도 등장해야한다. 문제를 풀기 위해서는 어떤 조건을 가지고 통일시킬 필요가 있다고 생각했다. 이를 위해 같은 알파벳이 등장한 인덱스들을 그래프 간선으로 표현해보았다. 그랬더니 좋은 아이디어가 떠올랐다. i번, j번, k번에 같은 알파벳이 등장했다면 i-j, i-k, j-k가 연결된다. 그런데 여기서 i-k를 제거해도 i와 k는 같을 수 밖에 없으므로 정보가 손실되지 않는다. 이점을 이용하여 각 문자를 '마지막으로 그 문자가 나온 위치까지의 거리'로 변환했다. 이전에 등장하지 않았다면 0으로 둔다. 패턴의 길이가 최대 500이므로 kmp 또는 해싱을 쓰면 subtask 2까지 해결할 수 있다. 단, 패턴의 0의 경우 단순히 비교해서는 안된다. 비교 대상인 부분 문자열의 글자가 0인 경우 당연히 일치하는 것이고, 0이 아니더라도 '마지막 위치'가 부분 문자열을 벗어났다면 이 경우 역시 일치하는 것으로 봐야한다. 전체 테스트케이스를 통과하기 위해서는 아호코라식을 적용해야 한다. 패턴의 길이에 따라 문자열의 값이 바뀌기 때문에 복잡해보이지만, 이 문제 역시 다른 아호코라식 문제처럼 하나의 포인터만으로 모든 패턴에 대해 탐색을 수행할 수 있다. 현재 노드에 해당하는 문자열의 길이가 몇인지 알고 있다면, 임의의 다음 문자에 대해 다음 상태에 해당하는 노드도 1개이며, fail에 해당하는 노드도 1개이기 때문이다. 제출을 할 수 없어 문제를 풀어보지 않았지만, 풀이 블로그를 통해 재밌는 테크닉을 배울 수 있었다. 각 패턴의 마지막 노드가 어디인지를 배열에 따로 저장함으로써, 그리고 각 노드 방문 횟수를 계산함으로써, 각 패턴의 발견 횟수를 탐색을 마친 후에 한꺼번에 구할 수 있었다.

2021-08-20
https://www.acmicpc.net/problem/3308
한 회사가 도시에 회사 로고를 붙이려고 한다. 로고는 서로 다른 높이의 n개 수직선으로 이루어져 있다. 입력은 s1, s2, ... , sn으로 구성되어 있다. 로고를 연속된 n개의 빌딩에 붙이려면, n개 빌딩 중 s1번째 빌딩이 높이가 가장 낮고, s2번째 빌딩이 2번째로 낮고, ... , sn번째 빌딩이 높이가 가장 높아야 한다. m개의 빌딩이 주어졌을 때, 로고를 붙일 수 있는 위치를 모두 찾아야 한다. KMP로 문제를 해결할 수 있다. n 길이의 로고를 패턴으로 표현하고, m개의 빌딩을 문자열로 나타냈을 때, 나는 문제를 풀기 위해서 각 글자를 '지금까지 매칭된 숫자들을 정렬했을 때, 현재 숫자의 인덱스 값'으로 변환했다. 이 경우, fail 함수를 타면서 꼬리를 아무리 잘라도 앞 쪽의 숫자들은 변화가 없기 때문에 문제 없이 KMP를 수행할 수 있을 거라고 생각했기 때문이다. 패턴을 앞서 말한 규칙으로 변환한 뒤, fail 함수를 만들고 문자열을 하나씩 보면서 kmp를 적용해주면 문제를 해결할 수 있었다. 다만 변환을 위해서는 좌표 압축 후 세그먼트 트리를 사용해야 했다. 때문에 내 풀이는 시간 제한 안에 들어왔지만, 조금 느리게 동작한다. 정해는 다음과 같다. 이 문제에서는 두 문자열이 동일한 구조를 가지면 match 된 것으로 간주한다. 모든 i, j에 대해 a[i] < a[j] <=> b[i] < b[j]를 만족한다면 a와 b는 match 된다고 할 수 있다. 이를 a~b라고 표현하자. 관찰해보면 길이가 k인 a, b가 a~b라면 1 <= x <= y <= k인 x, y에 대해 a[x...y]~b[x...y]를 만족한다. fail 함수를 빌드하려면 a[1...k-1]~b[1...k-1]임을 알 때, a[1...k]~b[1...k]인지 확인할 수 있어야 한다. 그러기 위해서는 a[q] < a[k] <=> b[q] < b[k]를 모든 q(1 <= q < k)에 대해서 만족해야 한다. 이 조건을 다르게 표현하면 어떤 1 <= r <= k인 r에 대해 a[k]가 a[1...k]에서 r번째 큰 숫자이고, b[k]가 b[1...k]에서 r번째 큰 숫자이다. 이 조건을 만족하는지 확인하기 위해서는 a[1...k-1]에서 a[k]보다 작으면서 가장 큰 숫자를 a[u]로 두고, a[1...k-1]에서 a[k]보다 크면서 가장 작은 숫자를 a[w]라고 했을 때, 정의에 의해서 a[u]<a[k]<a[w]이고, b[u]<b[k]<b[w] 식을 만족하는지만 확인하면 위의 조건을 만족한다고 볼 수 있다. 그 이유는 a[1...k-1]에서 a[u]보다 작거나 같은 숫자의 개수는 b[1...k-1]에서 b[u]보다 작거나 같은 숫자의 개수와 같기 때문이다. a[w], b[w]의 경우도 마찬가지. 그렇다면 u와 w는 어떻게 계산할 수 있을까. p[1...i]에서 p[i]보다 작으면서 가장 큰 숫자가 존재하는 인덱스를 g[i]라고 하고, p[1...i]에서 p[i]보다 크면서 가장 작은 숫자가 존재하는 인덱스를 h[i]라고 하자. 문제 조건에 의해 p[1...n]이 [1, n] 구간의 서로 다른 정수로 이루어져 있다. 여기서 우리는 g[i]와 h[i]를 i의 역순으로 계산할 수 있다. p[1...i] 숫자들이 증가하는 순서대로 양방향 링크를 가지고 있다면 g[i]와 h[i]를 O(1)만에 알아낼 수 있다. 그리고 p[i]를 제거할 때는 p[i]의 양쪽 원소를 서로 연결함으로써, 역시 O(1)만에 p[1...i-1]의 양방향 링크를 구할 수 있다. fail 함수를 구하고 나면 같은 방식의 KMP를 통해 문자열 상에 패턴이 몇 번 등장하는지 계산할 수 있다. 지금부터는 p[1...i]가 t길이의 가장 긴 접두사이면서 접미사를 가지고 있다면 p[1...i]의 t보다 작은 가장 긴 접두사이면서 접미사는 f[t]임을 증명해야한다. 먼저 p[1...i]는 f[t]길이의 접두사이면서 접미사를 가지고 있다. a~b이면 a[x...y]~b[x...y]이므로, p[1...t]와 p[i-f[t]+1...i]가 동일 구조일 때 p[1...f[t]]~p[i-f[t]+1]을 만족하기 때문이다. 두번째로, f[t]와 t 사이의 길이를 가지는 접두사이면서 접미사는 존재하지 않는다. 만약 그러한 u가 있다면(f[t] < u < t), p[1...u]~p[i-u+1...i]임을 의미하고, p[1...t]~p[i-t+1...t]이므로 p[1...u]~p[t-u+1...t]를 만족한다. 이는 fail 함수 정의에 어긋나므로 그러한 u는 존재할 수 없다.

2021-08-21
https://www.acmicpc.net/problem/16707
n개의 정점과 m개의 간선이 주어진다. 간선은 양방향 간선이며 같은 간선을 2번 이상 사용할 수 없다. 같은 정점은 여러번 방문할 수 있다. 1번에서 2번을 거쳐 n번으로 가는 최단 경로를 구해야한다. 2번에 도달하기 전에 n번 정점을 방문할 수 있다. MCMF로 문제를 해결할 수 있다. 소스에서 1번 정점과 n번 정점으로 간선을 연결하고,  2번 정점에서 싱크로 간선을 연결한다. 소스에서 1번과 n번으로 가는 간선의 용량을 1로 두고, 2번에서 싱크로 가는 간선의 용량을 2로 두면, 1번에서 2번으로 가는 최단 경로와 n번에서 2번으로 가는 최단 경로를 동시에 구할 수 있다. 다만, 양방향 간선임에도 불구하고 같은 간선을 2번 이상 사용하지 못한다는 조건 때문에 입력으로 주어지는 간선들을 조금 다르게 표현할 필요가 있었다. 간선에 해당하는 정점을 2개씩 둔다. 하나를 IN 간선 정점, 다른 하나를 OUT 간선 정점이라고 하자. 원래 간선이 u와 v를 연결하는 양방향 간선이라고 하면, u에서 IN 간선 정점으로 가는 간선 하나, v에서 IN 간선으로 가는 간선 하나를 연결한다. 용량은 1이고, 비용은 0이다. 마찬가지로 OUT 간선 정점에서 u로 가는 간선, OUT 간선 정점에서 v로 가는 간선을 연결한다. 이들 역시 용량은 1이고, 비용은 0이다. 마지막으로 IN 간선 정점에서 OUT 간선 정점으로 가는 간선을 연결한다. 용량은 1이며, 비용은 d이다. 이와 같이 모델링할 경우, u와 v를 연결하는 간선은 1번만 사용되며, d만큼의 비용이 들어가게 된다.

https://www.acmicpc.net/problem/17798
마을에 n(최대 150)명의 가정이 있다. 어떤 가정은 다른 가정이 소유하고 있는 집으로 이사를 가고 싶어하고, 이사를 가는데 ai의 비용이 든다. 이러한 요청이 m개 있을 때, 적절히 이사를 시켜서 얻을 수 있는 총 비용의 최대값을 구해야 한다. 한 집에서 이사를 나가면 다른 가정이 이사를 와야하므로, 이사를 오고 가는 관계를 그래프로 나타내면, 각 정점에 대하여 들어오는 간선과 나가는 간선이 1개 이하인 다수의 오일러 회로로 구성된다. 따라서 모든 정점마다 1번씩 소스와 싱크를 연결한 후 MCMF를 돌려주면 그러한 구성 중 최대비용을 구할 수 있을 거라고 생각했다. 하지만 팀노트의 MCMF에 사용된 SPFA는 음수 싸이클이 존재하면 정상적으로 동작하지 않았다. 정해에서는 이분 그래프의 매칭 문제로 모델링된다. 왼쪽의 n개 노드는 FAMILY 노드이며, 오른쪽의 n개 노드는 HOUSE 노드이다. u번 가정이 v번 가정의 집으로 이사를 가게된다면, FAMILY u 정점과 HOUSE v 정점을 매칭시켜주면 된다. 이 때 비용은 입력으로 주어진 -ai가 된다. u번 가정이 이사를 가지 않고 원래 있던 집에 남아있게 된다면 FAMILY u 정점과 HOUSE u 정점을 매칭시켜주면 된다.  이 때의 비용은 0이다. 간선 연결을 마친 후 MCMF를 수행해주면 총 비용에 -1을 곱한 값이 구하고자 하는 총 비용의 최대값이 된다.

2021-08-25
https://www.acmicpc.net/problem/9495
nxn 크기의 바둑판이 주어진다. n의 최대값은 50. 그 위에 흰돌과 검은돌이 놓여져 있고, 흰돌은 서로 인접해 있지 않다. 검은돌을 추가로 더 놓아서 흰돌을 잡을 수 있다. 이 때, 빈칸의 개수를 최대로 만드려고 한다. 검은돌을 놓아서 흰돌을 잡을 수 있으나, 검은 돌을 놓은 수 만큼 빈칸의 개수가 줄어들게 된다. 네트워크 플로우로 문제를 해결할 수 있다. 네트워크 플로우 문제임을 들어서 알고 있었고, 체스판 모양과 유사하여 이분 그래프까지는 접근 했으나, 정확히 어떻게 모델링을 해야할 지 생각하지 못 했다. 문제를 풀기 위해 사용되는 관찰은 이렇다. 흰돌이 있는 칸으로 득점을 하려면 흰돌을 따내어 빈칸으로 만들어야 하고, 인접한 빈칸은 검은돌로 채워져야 한다. 따라서 흰돌이 있는 칸으로 득점을 하려면 인접한 빈칸으로는 득점하지 못 한다. 반대로 빈칸으로 득점을 하려면 검은돌을 두지 않아야 하고, 인접한 흰돌이 있는 칸을 빈칸으로 만들 수 없다. 따라서 빈칸으로 득점을 하려면 인접한 흰돌이 있는 칸으로는 득점하지 못 한다. 이제 바둑판을 이분 그래프로 표현해보자. 흰돌이 있는 칸과 빈칸을 정점으로 나타내고, 흰돌이 있는 칸과 빈칸이 인접한 경우를 간선으로 그려주면 이분 그래프가 완성된다. 여기서 득점에 사용할 정점을 위에서 설명한 조건을 만족시키면서 최대한 많이 골라야하므로, 최대 독립 집합 문제와 같다. 이분 그래프에서 최대 독립 집합의 정점 수는 전체 정점의 수에서 이분 매칭 수를 뺀 값과 같다.

최대 독립 집합이란 정점들을 가능한 한 많이 선택하되, 선택된 정점끼리는 서로 인접하지 않는 집합을 말한다. 이 문제는 NP로 알려져 있지만, 이분 그래프에서는 다항시간만에 구할 수 있으며, 최대 독립 집합의 크기는 전체 정점의 수에서 최대 매칭의 수를 뺀 값과 같다.

관련하여 검색하다가 최소 버텍스 커버라는 개념을 알게되었고 추가로 정리하고자 한다. 최소 버텍스 커버란 정점들을 최소한으로 선택하여, 버텍스 커버에 포함된 정점들과 그 정점에 연결된 간선들을 제거했을 때 간선이 하나도 남지 않게 되는 집합을 말한다. 이분 그래프에서는 이 문제를 다항시간만에 구할 수 있으며, 최소 버텍스 커버의 크기는 최대 매칭의 수와 같다.

이분 그래프에서의 최소 버텍스 커버 문제가 최대 매칭의 수와 같다는 것은 쾨닉의 정리에 증명되어 있다. 쾨닉의 정리는 시간 날 때 읽어 보도록 하자. 이분 그래프에서의 최대 독립 집합은 최소 버텍스 커버의 여집합과 같다. 그 이유는 최대 독립 집합 안의 어떤 두 정점도 간선으로 연결되어 있지 않아야 하는데, 그 조건을 만족시키기 위해 삭제할 최소 개수의 정점을 고른 것이 최소 버텍스 커버이기 때문이다.

2021-08-27
SCPC-5 예선-1 3번
0번 좌표에서 x번 좌표로 1번 이상의 점프로 이동하려고 한다. 점프 할 때는 1칸 이동하거나 (이전 점프 거리)+1 칸 이동할 수 있다. f(x)는 x에 도달하기 위한 최소 점프 횟수를 의미한다. x, y가 주어졌을 때, f(x), f(x+1), ... , f(y) 중 최대값을 구해야 한다. 풀이가 떠오르지 않아 kdh 풀이 노트를 보고 해결했다. 작은 값에 대해 관찰을 해보면 대부분 x칸을 넘어가기 전까지는 점프 거리를 1씩 늘려가며 이동하다가, 도달한 좌표를 y라고 할 때, f(x-y)만큼 더 뛰면 된다. x가 작을 때는 반례가 존재하다가 x가 커지면 나타나지 않는다. x(x+1)/2 <= 10^11인 x까지만 f(x)를 미리 구해두면, x <= 10^11인 모든 x에 대해 f(x)를 빠르게 구할 수 있다. 약 45만까지만 구해주면 충분하다. f(x), ... , f(y) 중 최대값을 구하기 위해서는 또다른 규칙성을 사용한다. sum(x, y)를 x에서 y까지의 자연수 합이라고 하자. 앞서 발견한 규칙성에 반례가 존재하지 않는다고 가정하면 f(sum(1, a) + b) = f(sum(1, a)) + f(b)이고, f(sum(1, a+1)+b) = f(sum(1, a+1)) + f(b)이므로 f(sum(1, a) + b) < f(sum(1, a+1) + b) 이다. 즉, x1, x2 둘 다 최대한 연속해서 점프한 뒤 b번 점프해야 하는 거리라면, 둘 중 더 먼쪽이 반드시 점프도 더 많이 해야한다. 따라서 f(x) ... f(y) 중 뒤쪽의 45만개 정도만 계산해주면, 그 중 최대값을 구할 수 있다.

2021-08-30
SCPC-5 예선-2 5번
왼쪽 아래 꼭지점의 좌표가 (0, 0)이고 한 변의 길이가 m인 정사각형 U안에 n(최대 500000)개의 점이 있다. 각 점 p에 대해 평행한 정사각형 Q(p)의 정의는 다음과 같다. Q(p)의 왼쪽 아래 꼭지점은 p이고, Q(p)는 U 안에 위치한다. Q(p)의 내부에는 어떠한 점도 포함되어 있지 않으며, 앞서 설명한 조건을 만족하면서 가능한 가장 큰 정사각형이다. 모든 p에 대해 Q(p)의 한 변의 길이의 합을 출력해야 한다. Q(p)에 영향을 주는 것은, 첫 번째 점 p에서 U 경계선까지의 거리이다. 두 번째는 p를 지나는 기울기 1인 직선을 기준으로 y축 양에 방향에 있는 점들 중, x좌표가 p보다 크면서 y좌표가 가장 작은 점이다. 세 번째는 p를 지나는 기울기 1인 직선을 기준으로 y축 음에 방향에 있는 점들 중, y좌표가 p보다 크면서 x좌표가 가장 작은 점이다. 첫 번째는 단순히 좌표 값의 차를 계산해주면 된다. 두 번째와 세 번째를 계산하기 위해서는, 각 점이 기울기 1인 직선 기준으로 y축 양에 방향에 있는지, 음의 방향에 있는지 구분할 수 있어야 한다. 이를 위해서는 점의 좌표 x-y의 값을 비교해주면 된다. 비교 대상의 점을 q라고 했을 때, p의 x-y 값보다 q의 x-y값이 작다면 p를 지나는 기울기 1인 직선보다 y축 양의 방향에 있다는 뜻이고, 반대라면 y축 음의 방향에 있다는 뜻이다. 두 번째 조건에 해당하는 점을 p1이라고 하고, 세 번째 조건을 만족하는 점을 p2라고 하자. 정리하면 p1은 다음 3가지 조건을 만족해야 한다. 첫 번째로 p1은 p를 지나는 기울기 1인 직선 기준으로 y축 양의 방향에 있어야 한다. 두 번째는 p1의 x좌표는 p의 x좌표보다 커야 한다. 세 번째는 그러한 점들 중 y좌표가 가장 작아야 한다. 두 번째 조건은 점들을 x좌표 역순으로 탐색함으로써 해결할 수 있다. 이전의 x 좌표가 큰 모든 점들을 세그먼트 트리에 넣어주면, 세그먼트 트리에는 두 번째 조건을 만족하는 점들만 업데이트 된다. 첫 번째 조건을 만족하기 위해서는 각 점을 업데이트할 때, 점의 x-y값에 해당하는 인덱스에 업데이트해주면 된다. 그러면 p의 x-y 이하에 해당하는 범위에 대한 쿼리를 함으로써, 첫 번째 조건을 만족하는 점들에 대해서만 쿼리를 수행할 수 있다. 마지막으로 세 번째 조건을 만족하는 점을 찾기 위해서는, 업데이트를 할 때 각 인덱스에 y좌표 값을 업데이트 해주면 된다. 그 후 쿼리를 할 때 최소값 쿼리를 수행해주면 조건을 만족하는 점들의 y좌표 중 최소값을 구할 수 있다. p2 역시 비슷하게 구할 수 있다.

2021-08-31
SCPC-5 본선 4번
n개의 기지국이 정수 좌표 x1, x2, ..., xn에 위치한다. 모든 기지국들은 일정한 전파 범위 r을 가진다. xi에 있는 기지국은 [xi-r, xi+r] 구간에 전파를 보낼 수 있다. [0, L] 구간 전체가 하나 이상의 기지국으로부터 전파를 받을 수 있도록 기지국들을 이동시키려고 한다. 이 때, 기지국들은 정수 좌표로만 이동할 수 있다. 조건을 만족하도록 기지국들을 이동 시킬 때, 이동거리 합의 최소값을 계산해야 한다. 정해는 그리디하게 dp를 사용하면 된다고 한다. 하지만 어떤 블로그에서는 이 문제를 MCMF로 풀었고, MCMF를 연습할 겸 공부해서 풀어보았다. 먼저, 기지국들을 좌표 순서대로 정렬을 한다. 첫 번째 기지국의 왼쪽 영역, 마지막 기지국의 오른쪽 영역, 그리고 인접한 두 기지국 사이에 있는 영역에 해당하는 노드를 1개씩 둔다. 그러면 총 n+1개의 노드가 생긴다. 만약 i 노드 양쪽의 구간이 서로 겹칠 경우, 겹치는 만큼 해당 노드로 유량이 들어온다. 반대로 i 노드 양쪽 구간이 서로 떨어져 있다면, 떨어진 만큼 해당 노드에서 싱크로 유량이 빠져 나간다. 인접한 두 노드 사이에 용량이 무한이며, 비용이 1인 양방향 간선을 연결해주면 모델링이 끝이나고, MCMF로 구하고자 하는 답을 계산할 수 있다. 원리를 완전히 이해했다고 생각하지는 않지만 간략하게 적어보자. 유량이 i 노드에서 i+1 노드로 1만큼 흘렀다는 것은, i 노드의 오른쪽에 있는 기지국 r이 오른쪽으로 1칸 이동함으로써, r-1 기지국과 r 기지국 사이의 간격이 1 늘어나고, r 기지국과 r+1 기지국 사이의 간격이 1 줄어듦을 의미한다. 반대로 유량이 i 노드에서 i-1 노드로  1만큼 흘렀다는 것은, i 노드의 왼쪽에 있는 기지국 l이 왼쪽으로 1칸 이동함으로써, l 기지국과 l+1 기지국 사이의 간격이 1 늘어나고, l-1 기지국과 l 기지국 사이의 간격이 1 줄어듦을 의미한다. 유량이 최대로 흘렀다는 것은 기지국들을 이동시켜 모든 구간을 커버하게 되었음을 의미한다. 노드 사이에 유량이 1 흐를 때마다, 다시 말해 기지국들이 1칸 이동할 때마다 비용이 1만큼 들도록 모델링했기 때문에, MCMF로 계산된 최소 비용의 기지국들의 이동거리 합의 최소값과 같다.

2021-09-02
https://www.acmicpc.net/problem/2927
HLD 연습으로 풀어본 문제. 섬이 n개 있고, 처음에는 다리가 설치되어 있지 않다. 그리고 처음에 각 섬에 펭귄이 몇 마리 있는 지 알고 있다. q개의 쿼리를 처리해야 하는데, 1번 명령의 경우 a와 b 사이를 연결하는 쿼리이다. 만약 a와 b가 이미 연결되어 있다면 no를 출력하고 다리를 설치하지 않는다. 반대로 연결되어 있지 않다면 yes를 출력하고 다리를 설치해야한다. 2번 명령은 a섬에 사는 펭귄의 수를 x로 바꾸는 명령이다. 마지막으로 3번 명령은 a에서 b로 가는 경로에 속하는 섬 위의 펭귄 수의 합을 출력하는 명령이다. 만약 현재 a에서 b로 가는 경로가 없다면 impossible을 출력해야 한다. HLD를 빌드하기 위해서는 최종적으로 완성되는 그래프 형태를 알아야 했다. 그래서 쿼리를 미리 받아두고 disjoint set을 이용하여 그래프부터 완성시켰다. 완성되는 그래프에는 싸이클이 없지만, 하나의 트리를 이루는 것도 아니었다. 그래서 편의를 위해 1번 정점과 연결되어 있지 않은 정점들을 임의로 1번 정점에 연결했다. HLD를 빌드하고 난 뒤, 다시 disjoint set을 초기화 하고 쿼리를 하나씩 처리했다. 문제를 해결하기 위해선 HLD 알고리즘을 약간 수정해야 했다. 기존의 HLD 알고리즘은 두 정점 사이의 경로에 포함된 간선의 가중치에 대해 합, 최대값, 최소값 등의 연산을 수행한다. 하지만 이 문제에서는 두 정점 사이의 경로에 포함된 정점의 가중치에 대해 연산을 해야했다. 이를 위해서 i번 정점의 가중치는 i번 간선에 저장한다. i번 간선이란 i번 정점과 i번의 부모와 연결된 간선을 의미한다. 이후 쿼리를 할 때, 기존의 알고리즘과 똑같이 두 정점 사이의 경로에 포함된 간선에 대해 연산을 수행한다. 이 경우, 경로에 포함된 정점 중 가장 깊이가 작은 정점의 가중치가 결과에서 빠져있다. 따라서, 해당 정점만 결과에 포함시켜주면 우리가 구하고자 하는 값을 계산할 수 있다. 기존의 HLD 알고리즘을 보면 두 정점 u, v의 head 간선이 일치할 경우, 그리고 v의 깊이가 더 깊을 경우, [pos[u]+1, pos[v]+1) 구간에 해당하는 값을 결과에 포함시킨다. 이 문제에서는 u 정점이 가지고 있는 가중치 값도 필요하므로, [pos[u], pos[v]+1) 구간에 해당하는 값을 포함시키도록 수정하면 문제를 해결할 수 있다.

SCPC-6 예선 4번
n 길이의 숫자로 이루어진 문자열 t가 주어진다. 정수 k가 주어졌을 때, t에서 연속한 k개의 숫자로 이루어진 숫자들을 중복 상관없이 만든다. 그리고 m이 주어졌을 때, 임의의 a에 대해 [a, a+m] 구간에 포함된 수의 개수 최대값을 구해야 한다. 이 때, 부분 문자열로 숫자들을 만들기 전에, 문자열 t의 임의의 한 글자를 1로 바꿀 수 있다. 가능한 경우의 수 중 구간에 포함된 수의 개수 최대값을 계산해야 한다. n은 최대 50000이고, k는 최대 min(9, n)이며, m은 최대 10억이다. lazy propagation을 지원하는 세그먼트 트리를 사용하면 문제를 해결할 수 있다. 문자열 t의 한 글자를 1로 바꿀 경우, 목록에서 사라지는 숫자와 새로 추가되는 숫자의 개수는 각각 최대 k개이다. 일일이 글자를 1번씩 바꿔볼 경우, 숫자의 추가 및 삭제는 O(nk)번 일어나므로, 수를 추가, 삭제할 수 있고 포함된 수 중에서 임의의 m길이의 구간에 속하는 수의 개수 최대값을 빠르게 계산할 수 있는 자료구조가 있으면 문제를 해결할 수 있다. 이는 세그먼트 트리의 각 인덱스 i에 저장되는 값을 [i, i+m]에 속하는 수의 개수로 정의하면 구현할 수 있다. 인덱스는 문자열 t의 임의의 글자를 1로 바꾸거나 바꾸지 않았을 때 발생하는 숫자의 개수 O(nk)이면 충분하며, x값을 추가하거나 삭제할 때 세그먼트 트리 구간 [x-m, x] 구간에 1을 더하거나 뺌으로써 관리해주면 된다. n이 1000 이하인 subtask를 긁는 데는 성공했으나, 만점을 받진 못 했다. 아직 상수 커팅은 많이 부족한 듯 하다.

https://www.acmicpc.net/problem/11111
MCMF 연습으로 풀어봤다. n*m 크기의 두부판이 주어진다. n, m은 1 이상 50 이하의 정수이다. 2*1크기의 두부를 잘라, 두부 가격 합의 최대값을 구해야 한다. 각 2*1 크기의 두부의 가격은 각 칸의 등급에 따라 달라진다. 이는 문제에 배열로 주어진다. 예를 들어 A등급 칸과 C등급 칸으로 만들어진 두부의 가격은 7이다. 이분 그래프로 모델링 후 MCMF로 문제를 해결할 수 있다. x좌표와 y좌표의 값의 합이 짝수인 칸을 왼쪽 노드로 설정하고, x좌표와 y좌표의 값의 합이 홀수인 칸을 오른쪽 노드로 설정한다. 소스에서 왼쪽 노드들로 용량이 1이고 비용이 0인 간선을 연결하고, 오른쪽 노드들에서 싱크라 용량이 1이고 비용이 0인 간선을 연결한다. 왼쪽 노드에서 오른쪽 노드로 연결할 때는 해당 칸들이 서로 인접할 때, 용량이 1이고 비용이 -price인 간선을 연결한다. 그 후, MCMF를 돌리는데, 1의 유량이 흘렀다는 것은 하나의 두부가 만들어졌다는 것을 의미한다. 만들어진 두부 가격의 합을 최대로 해야하기 때문에, 싱크까지의 거리가 0 이상이 될 경우 MCMF를 종료했다. 다시 말해 cost 측면에서 이득이 되지 않는다면, 유량을 더 흘릴 수 있더라도 흘리지 않았다. 이와 같은 풀이가 가능한 이유는 MCMF가 유량을 흘릴 때는, 반드시 최소 비용의 경로를 찾아 흘리기 때문인 것 같다. 구글링 하다보니 MCMF 알고리즘을 수정하지 않고 문제를 해결할 수 있는 풀이도 있었다. 오른쪽 노드 뿐 아니라 왼쪽 노드에서도 싱크로 용량 1, 비용 0인 간선을 연결해주면, 양수 거리가 나오지 않게 되므로 최대 유량으로 구하고자 하는 답을 구할 수 있었다. 왼쪽 노드에서 싱크로 유량이 흐른 경우, 해당 칸을 버린 것과 같아진다. 오른쪽에 있는 노드 역시 유량이 흘러들어오지 않으면 매칭되지 않은 것이므로, 해당 칸을 버린 것과 같다.

2021-10-13
https://www.acmicpc.net/problem/23245
2021 ICPC 예선 H번으로 나왔던 문제. n 길이의 배열 p와 q가 주어진다. 각 원소의 값은 0과 1e6 사이의 값이다. p(i) < p(j) < p(k)이면서 q(i) < q(j) < q(k)인 서로 다른 (i, j, k)의 개수를 구해야 한다. 세그먼트 트리로 문제를 해결할 수 있다. 세그먼트 트리는 총 3개를 사용한다. seg(i, qnum)의 값은 조건을 만족하면서 i번째 인덱스까지 선택했고, 마지막으로 선택한 인덱스에 해당하는 q배열의 숫자가 qnum일 때 경우의 수를 의미한다. cnt(i, idx)는 조건을 만족하면서 i-1까지 선택했고, i번째로 idx를 선택했을 때 경우의 수를 의미한다. 그러면 cnt(i, idx)를 p값이 p(idx)보다 작은 인덱스만을 업데이트 했을 때의 seg(i-1, 0~qnum-1) 값으로 계산할 수 있다. 이를 위해 2n개의 값들을 pair( p(idx), q(idx) )로 저장해서 정렬한 다음에 순서대로 계산해주는데, p(idx)보다 작은 값만 세그트리에 업데이트 함으로써 p값이 p(idx)보다 작은 경우만 고려할 수 있게 만들고, 세그트리 [0, q(idx)) 구간에 쿼리함으로써 q값이 q(idx)보다 작은 경우만 고려하도록 만든다. 우리가 구하고자 하는 답은 seg(2, 0~MX)에 저장되어 있다.