2019-04-16
큐를 이용한 BFS를 할때 큐 대신에 vector 2개를 쓸 수도 있다. vector에 대해 go(x+1, y)..를 하면시간이 1 흘렀을 때마다 다른 작업을 할 수 있다.

2019-05-04
트리에서 maximum matching은 greedy 하게 leaf에서 부터 골라주면 된다. 사이클이 존재하는 그래프는 blossom 이라는 알고리즘을 돌려야한다.

2019-05-12
두 점을 지나는 직선을 표현하는 방법 중 하나로 ax-by=c가 있다. 이때 a,b를 먼저 구한 뒤 a,b를 서로소로 만든 후 c를 구해야한다. 오버 플로우 방지를 위해서다. 이러면 정수형태로 직선을 표현하고 구분할 수 있다.

map에 set을 조합하면 중복을 없애는데 효과적이다.

2019-05-17
어떤 그룹에 속한 원소들의 쌍의 개수를 셀려 한다. cnt[x]을 두고 cnt를 1증가시킬때 마다 증가시키기전에 ans += cnt[x]를 해주면 나중에 일일히 cnt[x]*(cnt[x]-1)/2 할 필요 없이 계산 가능하다.

케일리의 공식을 배웠다. 정점의 개수가 주어질때 만들 수 있는 트리의 개수를 구할 수 있다.

2019-05-19
LCM과 관련된 문제는 소수를 이용하는 경우가 많은 것 같다.

2019-07-31
2019 SCPC 1번
처음에 문제를 잘못 읽은 탓에 blossom matching algorithm으로 오해하고 금방 풀지 못 했다. 

2019-08-12
div2
gcd 알고리즘에 int로 되어있는 걸 lli로 바꾸는 과정에서 임시저장변수 역할을 하는 t 변수를 lli로 바꾸지 않아서 systest fail을 받았다.

div2 E
문제를 잘못 읽어서 런타임에러를 받다가 끝내 풀지 못 했다. 문자열의 총 길이가 10^6이었는데 n의 크기랑 혼동해서 배열크기를 10^5로 잡아둔 게 문제였다.

sa, kmp와 같은 문자열 알고리즘에서는 어떤 두 문자열을 합친 뒤 fail함수 또는 LCP를 구하는 식의 테크닉이 자주 쓰인다. 옛날에 공부할 때도 배운 거지만 이번 코드포스 업솔빙을 통해 다시 한번 상기하게 된다.

2019-08-29
좌표 압축을 map<int, set<int>> 이용하면 꽤 쉽게 가능.

2019-08-30
플로이드를 사용하면 위상정렬된 그래프에서 필요없는 간선을 지울 수 있다. a->b->c 가 연결되어 있다면 a->c 간선은 지울 수 있다는 뜻.

2019-11-11
ICPC Seoul Regional I번
간단한 파라메트릭 서치 문제였고 로직을 짜고 코딩하는데 그리 오랜 시간이 걸리지 않았다. 그러나 탐색 범위를 실수로 작게 잡는 바람에 WA를 2번이나 받았고, 이 문제를 푸는 데만 100분이 소요됐다. 

2019-11-24
map, set, vector 같은 표준 컨테이너의 경우 대부분 swap 함수를 오버로딩 해두는데, 원소가 n개씩 들어있더라도 포인터만 바꿔줌으로써 O(1)만에 swap이 가능하다.

2020-03-05
cerc 2012 d번(boj 3408)
특수한 알고리즘은 사용하지 않았으나, unique한 원소를 찾는 검사를 양쪽에서 시행함으로써 시간복잡도를 O(NlogN)으로 만드는 알고리즘이 있었다. 원래라면 단순히 검사했을 때 최악의 경우 O(N^2)이 나와야한다. 
T(n) = max(0<k<n) T(k) + T(n-k) + min(k, n-k)
T(n) = O(nlgn)

2020-03-09
머지소트 트리에 대해 공부했다. 임의의 구간에 대해 k 이상의 값을 가진 원소의 개수를 빠르게 구해낼 수 있다. 그 밖에도 다양한 연산이 가능해 보인다.

일반적인 트리를 전위 순회로 번호를 매긴 뒤, 서브트리에 대한 쿼리를 세그먼트 트리로 할 수 있다. 그 이유는 서브트리의 자식들은 루트 노드보다 큰 숫자를 가지며, 연속하여 위치해있기 때문이다.

2020-03-15
세그먼트 트리의 노드의 개수는 O(N)개이다. 즉, 세그먼트 트리의 공간복잡도는 O(N)이다.

세그먼트 트리의 update 시간 복잡도는 O(logN)이다. 트리의 높이는 O(logN)이고, 높이마다 갱신해야 하는 노드는 최대 4개이므로.

2020-08-01
UCPC - E
네트워크 플로우, 지도를 최소 비용으로 설치해서 소스에서 싱크까지 모든 경로가 5개의 지도를 거쳐야 한다. 최소컷을 이용한 문제. 최소컷이 나타난 간선의 용량을 INF로 바꿔주면서 5번 유량을 흘려주는 솔루션을 생각했었다. 하지만 이는 하나의 최소컷이 2개 이상의 경로에 동시에 나타날 때 오답을 구하게 된다. 정답을 구하는 솔루션은 K(K의 범위는 1~5)개의 그래프를 만든 뒤, 각 정점을 무시하고 넘어갈 수 있는 K-1개의 기회를 주는 것이다. 이후 최소컷이 나타난 정점을 모아서 출력하면 된다.

2020-09-30
https://codeforces.com/contest/1416/problem/B
요구하는 바를 달성하기 위해 필요한 일련의 작업을 출력하는 문제, 그 중에서도 작업의 수를 최소화 할 필요 없는 문제는 보통 간단한 규칙으로 해결 가능하다. 예제를 통해 규칙을 찾고, 어떻게 하면 제한된 횟수 내에서 쉽게 구현할 수 있을지 생각해보자.

2020-10-01
https://codeforces.com/contest/1408/problem/B
꼼꼼히 체크하지 않고 풀다가 sysfail 되었다. n=1, k>1인 상황에서 나의 솔루션은 0을 출력하는데, 문제에서 요구하는 답은 1이다.

https://codeforces.com/contest/1408/problem/E
싸이클과 관련된 문제는 크루스칼 알고리즘을 떠올려보자. 이 문제의 경우 집합과 정점 사이의 관계를 이분 그래프로 표현한 뒤, 최대 스패닝 트리를 구함으로써 해결할 수 있었다.

https://codeforces.com/contest/1408/problem/F
요구하는 바를 달성하기 위해 일련의 작업을 출력하는 문제였다. 그리디하게 접근하면 된다. 굉장히 trivial 한 방법이 있음에도 불구하고 어렵게 생각하다가 풀지 못했다. n개의 숫자를 모두 같도록, 또는 2개의 숫자로만 구성되도록 만드는 문제였으며, q의 크기가 대략 nlogn 정도여서 머지소트 형태의 답이 나올거란 걸 쉽게 추측할 수 있었다. 2^k 꼴의 경우 쉽게 모든 숫자를 같게 만들 수 있고, n이 2^k 꼴이 아닐 경우 n보다 작거나 같은 2^k를 구한 뒤 앞쪽의 2^k를 같게 만들고 뒤쪽의 2^k를 같게 만들어주면 된다. 

2020-10-03
https://www.acmicpc.net/problem/13937
다른 행성의 데이터를 다수의 datalink를 통해 지구로 보낼 때, 모든 데이터를 보낼 수 있는지 묻는 문제. 큐에 담긴 데이터를 현재의 datalink로 보내는 대신 이후의 datalink를 통해서도 보낼 수 있다. 한정된 자원을 효율적으로 사용할 것을 요구한다. 이 문제는 네트워크 유량으로 풀 수 있다. 큐에 해당하는 노드를 datalink의 개수만큼 만들어서 i번 datalink에서 비우지 못한 데이터를 i+1번 datalink에서 쓸 수 있도록 넘겨준다.

2020-10-05
https://www.acmicpc.net/problem/11676
경우의 수를 구하는 문제, 그 수가 10^18보다 클 경우 too many를 출력해야 한다. long long overflow를 유도하여 난이도를 높인 문제이다. 10^19 조차 overflow이기 때문에 조심. 해설을 통해 2가지 방법을 배웠다.

첫번째는 naive하게 연산하되 double형과 long long형 2가지 버전으로 답을 계산한다. double형 변수가 ansd이고, long long 변수가 ans일 때 10^18 보다 큰 지 확인하기 위해 if(ansd > 1.1e18 || ans > (ll)1e18) 와 같은 비교를 수행한다. (ans > 1e18)로 비교할 경우 ans가 double형으로 바뀌어 오답이 나올 수 있음에 주의. 

두번째 방법은 곱셈이 아닌 나눗셈을 통해 overflow를 판단하는 방법이다. now에 b[it]를 곱해야 한다고 할 때  if(now > INF / b[it]) 와 같은 비교를 통해 INF보다 커질 수 있는지 확인한다. INF 는 10^18+1이다. 이 때 나눗셈 연산에서 floor연산이 일어나므로 등호를 넣을 경우 문제가 생길 수 있으니 주의.

2020-10-10
https://www.acmicpc.net/problem/20043
ICPC 예선 H번. 무방향 그래프 상에서 간선 가중치의 곱이 음수인 싸이클이 존재하는 지 판단하고, 존재한다면 그 중 하나를 출력하는 문제였다. 하지만 실수로 인해 WA. 음수 싸이클은 찾으면 그 즉시 출력하도록 코딩했는데, 출력을 하고 난 뒤 재귀 탈출을 제대로 하지 않았다. DFS 함수의 첫부분에서만 if를 통해 탈출하도록 하였는데, 알고보니 이미 시작된 함수에서 또다시 음수 싸이클을 찾을 경우 몇번이고 출력을 하게 된다.

2020-10-20
https://www.acmicpc.net/problem/20039
http://codeforces.com/blog/entry/18051
ICPC 예선 문제 중 하나. 평범한 세그먼트 트리 dp 문제. 다만 평소에 쓰던 탑다운 세그먼트 트리를 썼더니 시간초과가 났다. 어쩔 수 없이 바텀업 세그먼트 트리를 공부하기로 했다. 설명은 위에 적힌 코드포스 링크에서 확인할 수 있다. 

바텀업 세그먼트 트리에서는 k번째 작은 수를 O(logN) 만에 구할 수 없는 것 같다. 이분탐색으로 O(log^2) 은 가능하다. 또한 바텀업 세그먼트 트리에서는 lazy propagation을 구현하기 까다롭다. 그래서 대부분 lazy를 사용해야할 경우 탑다운을 사용한다고 한다. scpc를 위해서라도 빠른 바텀업을 공부하자.

2020-10-27
https://www.acmicpc.net/problem/20045
https://koosaga.com/262
ICPC 예선 문제. 최대 250만 길이의 수열이 주어지면, 연속적인 부분 수열의 합 중 가장 큰 값 k개를 출력하는 문제였다. 퍼시스턴트 세그먼트 트리를 활용한 O((n+k) logn)풀이는 다음과 같다. 부분합을 좌표 압축한 뒤 순서대로 퍼시스턴트 세그먼트 트리에 넣은 후, i=1~n에 대해 psum[i]-psum[j]의 최대값을 퍼시스턴트 세그먼트 트리로 찾는다. 어떤 i에서 최대값이 나오는지는 heap을 이용하여 O(logn)만에 찾을 수 있다. 그리고 i에서 최대값을 찾았다면 i에서는 두번째로 큰 값을 찾아야 하므로 이를 마찬가지로 퍼시스턴트 세그먼트 트리로 두번째 값을 찾은 뒤 heap에 넣어준다.

평소에 문제 풀 때 상수 커팅 연습을 해보자. '동적할당을 정적할당으로 바꾸기', '재귀 수행을 반복 수행으로 바꾸기' 등등이 있는 것 같다. map, set과 같은 stl container는 상수가 크기 때문에 조심해야한다. 퍼시스턴트 세그먼트 트리 구현 방식을 동적할당에서 정적할당으로 바꾸는 것으로 속도를 2배 향상시킬 수 있었다.

#pragma GCC optimize("O2") 
위 최적화 옵션에 대해서 배웠다. 정확하게 공부하지는 않았지만, 최적화 옵션을 설정하여 코드의 성능을 향상시켜주는 듯 하다. 20045 문제를 O(n logn logn) 솔루션에 펜윅트리, 최적화 옵션을 사용하여 AC를 받았다.

2020-10-28
scpc 홈페이지에는 codeground note가 존재한다. kmp, convexhull 등 주요한 알고리즘들이 코드까지 나와 있다. 내 팀노트를 외워가는 것보다 거기에 있는 코드를 연습하는 게 더 좋을 지 모르겠다.

2020-10-29
펜윅 트리, 다익스트라, kmp 등 유용한 알고리즘들이 codeground note에 존재한다. 하지만 본선 문제가 여기에서만 출제되는 게 아니기 때문에 외워야하는 알고리즘이 훨씬 많다. 그러므로 이런 cheat note가 있다는 것만 기억해두고 팀노트를 외우자.

2020-10-30
scpc 2019 본선 3번. 방향의 명시되지 않은 bst가 주어졌을 때, 대소 관계에 대한 정보가 r개 주어진다. 그러면 r+1단계에서 만들 수 있는 bst의 개수를 구하는 문제였다. lca부터 직접 구현하는 연습을 했다. 하지만 lca에 대한 이해가 부족해서 lca를 완벽하게 짜지 못 했다. 라이브러리를 완벽하게 외우고 이해하는 것이 중요할 듯 하다.

scpc 2019 본선 3번을 풀 때, 이진트리 상에서 어떤 노드가 부모 노드의 왼쪽에 있는지, 오른쪽에 있는지 판단하기 위해 adj 배열을 확인했다. 하지만 이 방법은 리프노드 일때 예외처리를 안 해주면 런타임에러가 발생한다. 가장 좋은 방법은 inorder 탐색 순서 번호를 저장해둔 뒤, 순서 번호를 비교하는 것.

작년에는 scpc 2019 본선 현장에서 3번을 끝까지 풀지 못 했다. 지금와서 코드를 다시 읽어보니 lca(u, v)가 u 또는 v일때도 방향이 정해진다는 사실을 깨닫지 못한 것 같다. 문제를 잘 읽도록 하자.

2020-11-08
SCPC 2020 2번
주어진 그래프를 SCC로 묶어주면 DAG가 된다. DAG가 위상정렬된 상태에서 Su->Sv 간선의 방향을 바꾸었을 때, 새롭게 생기는 SCC의 크기는 Su와 Sv 사이에 위치하는 SCC들의 크기의 합이다. 정점의 개수 n은 최대 1000이므로, O(n^2)에 전처리를 해주면 풀 수 있는 것 같다.

2020-11-22
https://codeforces.com/contest/1451
작년과 비슷한 실수를 하고 말았다. 빠르게 풀기 위해 제대로 된 검증 없이 구현에 들어갔고, WA와 TLE를 받았다. 절차를 지키자.

2020-12-20
https://codeforces.com/contest/1463/problem/C
integer overflow 때문에 hack 당한 문제다. 좌표 값과 명령을 내리는 시간 값이 [-1e9, 1e9] 범위 내에 있으며, 곱하기 연산을 하지 않기 때문에 오버플로우가 날 거라고 생각하지 못 했다. 하지만 좌표 0 에서 1e9까지 갔다가 1e9 시간에 -1e9로 가라는 명령을 내리면 도착 시간이 3e9가 되어 오버플로우가 발생한다.

2020-12-21
https://codeforces.com/contest/1458/problem/C
조금 신기했던 문제. 2차원의 배열이 있고, 각 행과 열은 1...n이 1번씩 등장하는 수열로 이루어져 있다. 배열 전체에 대해 상, 하, 좌, 우로 이동, 그리고 모든 행에 inverse 연산, 모든 열에 inverse 연산을 취할 것이다. 이 때, p 수열에 inverse 연산을 한 결과 수열이 q일 경우,  i = 1...n 에 대해 p_{q_i} = i을 만족한다. 이는 p의 각 원소에 대해 인덱스 값과 배열 값을 바꾸는 것과 같다. 이러한 규칙 덕분에, 문제에 설명된 모든 연산은 각 원소에 대해 독립적으로 할 수 있고, (i:0, j:0, k:0)에만 연산을 누적함으로써 O(m + n*n) 시간 복잡도로 문제를 해결할 수 있다.

2020-12-21
https://codeforces.com/contest/1464/problem/A
공식 풀이에서는 룩의 좌표 (x, y)를 간선 x->y 로 변환하여 그래프 형태로 모델링했다. 룩의 개수는 최대 n-1개이며, 모든 룩은 서로 잡아먹을 수 없는 위치에 있다. 다시 말해, 그래프에서 각 정점의 indegree와 outdegree는 최대 1이다. 때문에 그래프의 형태는 self-loops, paths, cycles 의 조합으로만 나타난다. 룩의 이동은 그래프의 시작점 또는 끝점을 다른 정점으로 옮기는 것을 의미하며, 모든 그래프를 self-loops 형태로 만들어야 한다. cycle은 1번의 이동으로 path로 만들 수 있고 path는 모든 간선을 순서대로 self-loop로 만들면 된다.

다른 사람들은 좀 더 쉽게 풀었다. (x, y)를 양방향 간선 x-y로 변환하고, 그래프를 만든다. 이 때, self-loop가 아닐 경우 1회 이동해야하며, cycle이 발생할 경우 1회 더 이동해야 한다. disjoint set을 사용할 경우 매우 간단하게 문제를 해결할 수 있다.

2020-12-21
https://codeforces.com/contest/1464/problem/B
0, 1, ? 로 이루어진 문자열이 주어지고 x, y가 값이 주어진다. x는 완성된 문자열에서 subsequence로 01이 등장할 때 받게되는 angry 점수이고, y는 10이 등장할 때 받게되는 angry 점수이다. 인접한 2개의 ?에 1,0을 넣었을 때, 0,1을 넣었을 때 점수를 비교했더니 오직 x, y의 대소 관계만이 angry 점수에 영향을 미친다. 그러므로 x 값이 y 값보다 크다면, 01이 들어간 곳을 10으로 바꿈으로써 angry 점수를 더 작게 만들 수 있고, 반대 역시 성립한다. 따라서 angry 점수를 최소화 하려면, ?에 들어가는 값은 111...000 또는 000...111 형태여야 한다.

2020-12-23
https://www.acmicpc.net/problem/20171
icpc 2020 본선 c번 문제. 트리 형태의 그래프가 주어졌을 때, 카페를 설치하기 좋은 good place를 찾는 문제다. 그대로 풀어도 간단한 dp 문제지만, good place가 아닌 bad place를 찾음으로써 더 쉽게 풀 수 있었다. 서브트리의 크기가 k인지 아닌지에 따라 bad place 여부를 판단할 수 있다.

2020-12-24
https://www.acmicpc.net/problem/20173
icpc 2020 본선 e번 문제. 나는 이 문제를 그래프의 형태로 모델링했다. d 배열에 영향을 미치는 것은 비교 연산 중에서도 1 차이 나는 숫자들 간의 비교 연산뿐이다. 이 비교 연산의 결과를 연산 정점, 승리한 정점 간의 간선으로 나타냈다. 그 후 많은 경우의 수들 중에 d 배열을 만드는 방법이 있는지 찾았다. 나는 1번째 원소부터 차례대로 간선을 이어 주면 그리디로 충분히 풀 수 있다고 판단했고, 계속 그리디로 접근했다. 하지만 끝내 ac를 받지 못 했고 대회가 끝났다.

구사가 역시 나와 비슷하게 그래프 모델링으로 접근했다. 약간 다른 점은 비교 연산 자체를 위한 정점을 따로 만들지 않은 채, x defeats y 일경우 y->x 의 간선을 생성했다. 그 후 dp를 이용하여 풀었다. i번째 원소까지 확인하고, 마지막 간선의 방향이 j, k 였을 때, d 배열을 i까지 완성할 수 있는가를 dp[i][j][k]에 저장했다. 

이 문제를 다시 풀어보니, 그리디 접근 방법 역시 옳았다. 이번에는 그래프 형태로 모델링하지 않고 nxn 배열 상태에서 접근을 했는데, 1vs2의 결과를 d[1]에 따라 정해주고 나면 자연히 2vs3, 3vs4, 4vs5가 정해지는 걸 확인할 수 있었다. 마지막 원소를 확인해주지 않아 wa를 한 번 받았다. 

이후, 대회 중 생각했던 접근 방식으로 다시 풀어보기도 했다. 역시나 첫번째 원소에 간선을 연결하고 나면, 다음 원소들에 연결 될 간선 역시 정해졌다. 이전에 연결한 간선이 1라운드 간선인지, 2라운드 간선인지는 중요하지 않다. 상황에 맞게 1라운드, 혹은 2라운드의 간선을 연결하면 될 뿐이다.

2020-12-29
https://www.acmicpc.net/problem/20176
icpc 2020 본선 h번 문제. FFT 유형의 문제였는데, 일반적인 FFT 문제들에 비해 쉽다고 한다. 왜냐하면 FFT 문제들은 보통 그 문제가 FFT인지 알기가 어려운 데에 비해 이 문제는 그냥 팀노트를 베끼면 될 정도로 간단하기 때문. 아직 FFT 유형을 완전히 이해 못 했지만 알게된 것을 간단히 써보자면, convolution 자체가 naive 구현으로는 O(N^2)이 필요하지만, FFT는 O(NlogN)에 계산할 수 있고, 그 결과는 O(N) 메모리에 누적 저장할 수 있다는 것을 이용한 문제가 많은 것 같다.

2020-12-31
https://codeforces.com/contest/1469/problem/D
구간의 크기가 점점 0.5승(sqrt)만큼 작아진다면 그 구간의 개수는 최대 log(logN) 이다.

2021-01-03
https://www.acmicpc.net/problem/20177
icpc 2020 본선 i번 문제. 오프라인 쿼리에 세그먼트 트리를 응용하는 문제. 쿼리를 y좌표 순으로 정렬 후 순서대로 처리하는데, 처리하기 전에 y좌표 이전에 있는 모든 구간을 세그먼트 트리에 저장한다. 이때, 인덱스는 구간의 합이 되고, 그 값은 시작점이 된다. 그 후 쿼리의 답을 계산하기 위해 [-INF, u] 구간에서 값이 쿼리의 시작점 x 이상인 인덱스 중 가장 오른쪽의 것을 찾으면 된다. y좌표 이전의 구간들만 저장했기 때문에 y좌표에 대해서는 신경쓰지 않아도 되며, 구간의 시작점은 x 이상이면 되기 때문에 최대값만 유지해도 된다. 만약 인덱스를 시작점으로 했다면, 시작점이 중복될 경우, 중복된 모든 값들을 저장해야할 것이다. 하지만 모든 값들을 저장한다고 해서 그 중 u보다 작거나 같으면서 가장 큰 값을 찾을 방법은 없을 것 같다.

2021-01-05
https://www.acmicpc.net/problem/18084
케이스 분류해서 풀면 되는 굉장히 쉬운 문제, 라고 생각했으나 double형 오차 때문에 wa를 여러번 받았다. 입력으로 주어지는 값은 1과 20 사이이며, 소수점 아래 2번째 자리까지 표시되기 때문에 연산 중에 값이 소실되는 일은 없을 거라 생각했다. 그런데 직접 테스트해보면 알겠지만 9.7이 입력으로 들어오면 100을 곱하여 int 형변환을 하는 과정에서 969로 되어버린다.

2021-01-07
vector<T> 의 resize 함수를 사용할 때 주의할 점. resize를 호출할 때 매개변수로 초기값을 넘겨줄 수 있는데, 이 때 초기값은 새로 추가되는 원소에만 적용된다.

2021-01-08
https://www.acmicpc.net/problem/13575
FFT를 K번 해주면 되는 간단한 문제. 하지만 일일이 K번 곱해줄 경우 시간초과가 나므로 분할정복을 적용해야한다. FFT를 하는 도중에 int overflow가 발생할 경우 배열의 크기가 예상과는 달라진다. 또한 FFT 특성상 배열의 크기가 예상한 것보다 커질 수 있다. 때문에 계수가 0인 항을 없애주는 작업을 하지 않을 경우 MLE가 발생했다.

https://www.acmicpc.net/problem/14958
문제에 사용되는 문자가 많지 않을 경우, 반복문에서 상수 문자열을 사용할 수도 있다. 예를 들어 ATCG가 문제에서 사용된다면, i를 0에서 3까지 증가시키면서 "ATCG"[i]와 비교하면 원하는 A, T, C, G를 한번씩 사용할 수 있다.

2021-01-12
https://www.acmicpc.net/blog/view/37
부동 소수점 오류로 오답을 받는 경우. 실수 변수는 정확한 값을 가지고 있지 않기 때문에 사용에 유의해야 한다. 기억해둘 건 double형 사용하기, 정수로 캐스팅할 때는 1e-6 ~ 1e-9 정도를 더해서 캐스팅 하기, 등호 사용하지 말고 값의 abs(A-B)<EPS 사용하기 정도이다.

https://www.acmicpc.net/problem/15856
포함 배제의 원리에 대해서 공부했다. 진리 집합 A1, A2, ..., An에 대해서 n(A1 합 A2 합 ... 합 An)을 구하기 위해서는 n(A1) + ... + n(An) - n(A1 교 A2) - ... - n(An-1 교 An) + n(A1 교 A2 교 A3) + ... 를 계산하면 된다고 한다. 간단히 말해서 교집합된 집합의 개수가 홀수면 더하고, 짝수면 빼준다. 합집합은 집합의 개수가 많을 수록 경우의 수가 늘어나기 때문에 교집합의 형태로 바꾸어 계산을 쉽게 만든다.

2021-01-17
https://www.acmicpc.net/problem/18083
최단경로를 dp를 이용하여 찾는 문제. 처음엔 다익스트라로 구현을 했다가 TLE를 받았다. 간선을 1개, 2개, ..., n-1개 거친 최단경로를 모두 구해야 했기 때문에 새로 모델링한 그래프의 정점 개수는 n*n개, 간선 개수는 n*m개가 되었다. 단순히 dp로 계산하면 O(n*n + n*m)이지만, 다익스트라를 사용할 경우 O(n*m*logn)이 되어 시간복잡도가 커진다. dp로 계산할 수 있는 이유는 새로운 그래프가 싸이클이 가지지 않는 DAG이기 때문이다.

2021-01-20
https://codeforces.com/contest/1474/problem/C
규칙을 찾고 multiset을 이용하여 시뮬레이션을 해주면 되는 문제였다. 하지만 존재 여부를 확인하기 위해서 multiset의 find 함수를 사용하지 않고 count 함수를 사용해서 TLE를 받았다. 대회 중이었기 때문에 깊게 생각할 수 없었고, logN 때문에 TLE가 났다고 생각해서 multiset을 사용하지 않는 솔루션을 다시 구현했다. multiset의 count 함수는 O(N)의 시간복잡도를 가진다.

2021-01-28
https://www.acmicpc.net/problem/13261
https://www.acmicpc.net/problem/13262
https://www.acmicpc.net/problem/20180
https://www.acmicpc.net/problem/14636
divide and conquer optimization 문제. dp(i, j) = min(k<j)(dp[i-1][k] + c[k][j]) 와 같은 점화식을 가지고 c < d 이고, dp[i][c]를 최소화하는 k가 optc, dp[i][d]를 최소화하는 k가 optd일 때, optc <= optd를 만족한다면 적용 가능하다. 일반적으로는 dp table을 채우기 위해 O(n * m^2)의 시간복잡도가 필요하지만, 분할정복법을 이용하면 O(n * mlogm) 만에 dp table을 채울 수 있다. 이 기법은 dp 문제에만 적용할 수 있는 건 아니며, icpc에 출제된 문제 역시 dp문제는 아니었다.

2021-02-01
https://www.acmicpc.net/problem/13548
mo's 알고리즘을 복습 중이다. 쿼리를 { l/sqrt(n), r } 순으로 정렬하여 처리하면, naive하게 계산했을 때 모든 쿼리를 O(M + N * sqrt(N)) 만에 계산할 수 있다. 정렬만 해두고, 구간을 늘리거나 줄일 때 값을 잘 처리해주면 쉽게 풀 수 있다. 또한 문제의 유형이 구간 내의 구분되는 수의 개수, k번 등장하는 수의 개수 등을 묻는다고 하니, 유형을 판별해내는 것도 그리 어렵진 않다.

2021-04-11
https://codingcompetitions.withgoogle.com/codejam/round/000000000043585d/00000000007549e5
코드잼 1A 1번 문제. N개의 숫자가 주어졌을 때, 각 숫자의 우측에 임의의 숫자를 붙여 정렬된 상태를 만들고자 한다. 이 때, 붙이는 연산의 최소 횟수를 구해야한다. BigInt가 필요 없을 것이라고 생각하고 접근했지만, 같은 자리의 숫자만 N개 주어졌을 때 long long 범위를 충분히 넘어서는 문제였다. 0만 붙이거나, 이전 숫자 +1로 만드는 게 최적이다.

https://codingcompetitions.withgoogle.com/codejam/round/000000000043585d/00000000007543d8
코드잼 1A 2번 문제. 2와 499 사이의 소수가 적힌 카드가 최대 1e15개 주어졌을때, 2개의 그룹으로 나누어 1그룹에 속한 숫자의 합과, 2그룹에 속한 숫자의 곱이 같도록 만드는 경우 중 가장 큰 값을 구하는 문제였다. 이 때 2그룹의 경우 60개 이상의 카드가 들어가지 못한다는 점을 이용하여 매우 작은 경우의 수만 체크해서 정답을 구할 수 있다. sum을 모든 숫자의 합이라고 했을 때, 1그룹의 값은 [sum - 60 * 499, sum] 사이의 값만 가능하다. 해당 값을 2에서 499 사이의 소수로만 인수 분해를 시도하여 정답이 될 수 있는 후보들을 모두 구해 최대값을 계산한다.

2021-04-13
https://www.acmicpc.net/problem/13998
젠가 게임을 시뮬레이션 한다. 블럭 1개를 제거했을 때 균형이 무너지는지 체크해야 한다. 처음 문제를 풀 때는 블럭을 제거한 높이에서만 체크를 했지만, 현재 높이에서 제거한 블럭 때문에 아래층에서도 균형이 무너질 수 있기 때문에 모든 높이에서 체크해야 한다. 꼭대기층에서부터 값을 누적하면서 내려오면 빠른 시간 안에 모든 높이를 체크할 수 있다.

2021-04-14
https://www.acmicpc.net/problem/14000
소수로 이루어진 집합들을 합 비내림차순, 사전순으로 출력했을 때, a번째 글자부터 b번째 글자를 출력하는 문제. dfs를 이용하여 순서대로 탐색하는데, dp를 이용하여 정답에 포함되지 않는 경우 가지치기하여 시간 복잡도를 줄인다. sum < prime[i]인 경우 가지를 치지 않아 해당 소수를 더하지 않는 방향으로 계속 내려가는 바람에 시간초과를 받았다

2021-04-16
https://www.acmicpc.net/problem/13991
cactus 그래프를 3가지 연산, 4개의 색상을 이용하여 build하는 문제. cactus를 simple cycle과 bridge로 분리한 뒤, dfs를 이용하여 하나하나 완성해가면 된다. 하위 그래프들을 모두 완성시키고, 연결할 정점의 색상을 1로 만들어두면 현재 정점에서 이러한 정점들을 조합해 새로운 그래프를 완성시킨다. 각 색상의 역할을 효율적으로 정하는 것이 중요하다.

2021-04-17
https://codeforces.com/contest/1508/problem/B
k번째 almost sorted permutation 을 출력하는 문제. almost sorted permutation란 1~n의 값으로 구성된, 그리고 i = 1 ~ n-1 일때  a(i+1) >= a(i)-1을 만족하는 수열이다. 감소할 때는 1씩 감소해야하고, 증가할 때는 이전의 숫자들보다 커져야 한다. 이러한 수열을 bit string으로 표현할 수 있으며, 수열의 개수는 2^(k-1)개이다. 이 때, bit string에서 값이 1일 경우 다음 숫자가 1 작아지고, 0일 경우 커진다. 규칙을 대회 도중 어느정도 알아차렸지만 i = 1 ~ n-1 에서 잘못 생각하여 n번째 숫자는 이러한 조건들에서 제외된다고 해석했다.

2021-04-19
https://www.acmicpc.net/problem/11740
돌이 최대 1000개 있는 강을 건너려고 한다. 1개의 돌을 추가할 수 있을 때, 강을 건너기 위해 점프해야하는 거리의 최대값을 최소화하는 돌의 좌표 구해야한다. 문제를 풀기 위해 점프 거리의 최대값에 대해 이진 탐색을 수행하고, dp를 이용하여 문제를 풀었다. 이 때 시간 복잡도는 O(n^2 logw)이다. 하지만 다익스트라를 2번 호출함으로써 O(N^2)으로 문제를 해결할 수 있다. 다익스트라는 힙을 사용하지 않는 다익스트라이며 왼쪽 강가, 오른쪽 강가를 출발점으로 하여 2번 호출한다. 이후 모든 점의 쌍의 중심에 돌을 추가해봄으로써 답을 구할 수 있다.

https://www.acmicpc.net/problem/11745
n개의 도시와 n+20개의 도로가 있을 때, 1번 도시에서 출발하여 모든 도시를 1번씩만 방문하고 다시 1번 도시로 돌아오는 경로를 찾는 문제. np-hard로 유명한 tsp 문제와 똑같지만, 도로의 개수가 작아 이를 잘 이용해야한다.  그래프가 분리되어 있는 경우를 고려하지 않은 솔루션으로 wa를 몇번 받았고, 정해는 다음과 같다. 1번 도시와 indegree 또는 outdegree가 1보다 큰 도시를 special한 도시로 간주한다. 그 외의 도시는 반드시 지나야하는 도시이므로 special한 도시들 사이의 간선으로 압축한다. 압축된 그래프에서 1번 도시에서 모든 special한 도시를 지나 다시 1번 도시로 돌아오는 경로를 찾는다. 이러한 경로의 개수는 O(2^(m-n)) 이므로 시간 내에 문제를 풀 수 있다.

2021-04-20
https://codeforces.com/contest/1514/problem/D
최대 300000 크기 배열이 주어 졌을때 쿼리에 대한 답을 계산하는 문제다. 쿼리 구간의 길이를 len이라고 했을 때 구간 내의 최빈값의 등장 횟수가 (len+1)/2 번 초과하는지 확인하고, 초과한다면 몇번 등장하는지 계산해야한다.

이 문제를 해결하기 위한 여러 가지 방법이 있다. 첫번째는 랜덤 접근 방법. 구간 내에 랜덤으로 원소를 고르고, 해당 값이 구간 내에 몇번 등장했는지 이진 탐색으로 구한다. 쿼리당 40번 정도 반복하면 틀릴 확률이 2^(-40) 정도로 굉장히 작다. 두 번째는 세그먼트 트리를 이용하는 방법이다. 이 때, 세그 트리 노드의 반환 값은 해당 노드 범위 내의 최빈값이다. 이 방법은 통상적으로 구간 내의 최빈값을 구하지 못하지만, 최빈값이 구간 길이의 절반을 초과하여 등장할 경우엔 최빈값을 구할 수 있다. 마지막으로 pst를 이용한 방법이다. (len+1)/2번 이상 등장한 숫자는 구간 내의 숫자들을 정렬했을 때 반드시 중앙에 위치하게 된다. 따라서 [l, r] 트리의 (r-l+1)/2번째 숫자를 pst로 구한 다음, 해당 숫자의 등장 횟수를 마찬가지로 pst로 구하면 (len+1)/2번 초과하여 등장했는지 확인할 수 있다.

2021-04-22
https://www.acmicpc.net/problem/11737
주어진 cactus 그래프에서 간선 하나를 지우고 새로운 간선을 추가했을 때, cactus를 유지하는 경우의 수를 구하는 문제다. 각 간선이 cycle 간선인지, bridge 간선인지 구분한 다음 경우의 수를 계산해주면 된다. cycle 주위의 bridge 간선 개수를 알아야하는데, 한 정점에 여러 개의 cycle이 연결되어 있는 경우를 생각하지 못해 wa를 여러번 받았다. dp를 이용하여 bridge 간선 그룹이 시작되는 최상단 정점에 bridge 그룹의 크기를 저장하고, 해당 정점에 연결되어 있는 cycle에 필요한 연산을 해준다. 그 다음 dfs를 통해 최상단 정점에는 연결되어 있지 않지만, 그 아래 정점에 연결되어 있는 cycle에 똑같이 필요한 연산을 해준다.

2021-04-26
https://codingcompetitions.withgoogle.com/codejam/round/0000000000435baf/00000000007ae694
코드잼 A 문제. 시계 바늘 3개의 각도가 주어졌을 때, 현재 시각을 맞추는 문제이다. 입력에서 시침, 분침, 초침을 구분할 수 없기 때문에 6가지의 경우의 수를 모두 고려해야한다. test set 2까지는 nano second 단위는 고려할 필요가 없기 때문에 모든 시간 값을 각도로 변환하여 비교함으로써 풀 수 있다. test set 3에서는 모든 시간 값이 아니라 모든 hour 단위 값만 확인하면 된다. hour 값이 정해지면 시침과 분침 사이각을 계산함으로써 정확한 시각을 알 수 있기 때문이다. 계산한 시각으로 초침 각도 역시 계산하여 정답인지 확인한다.

https://codingcompetitions.withgoogle.com/codejam/round/0000000000435baf/00000000007ae4aa
x metal 1개를 분해하여 입력으로 주어진 metal들을 모두 만드려고 한다. 이 때 최소값 x를 구하는 문제이다. x가 주어졌을 때 입력으로 주어진 metal을 모두 만들 수 있는지 확인하는 방법은 그리디 솔루션이면 충분하다. 높은 값의 metal부터 살펴보면서 부족할 경우 impossible, 남을 경우 남은 metal을 쪼개어 작은 값의 metal을 2개 만든다. 확인해야 할 x값은 402가 최대이며, 이 모든 x에 대해 시뮬레이션함으로써 답을 구할 수 있다.

2021-04-30
https://www.acmicpc.net/problem/10596
좌표축 위에 점들이 n+1개 존재하며 0번 점은 0번에 고정, 다른 점들은 원점 오른쪽에 위치한다. 0 <= i <= n-1 일때, i번 점과 i+1번 점 사이에는 rope가 연결되어 있다. 최소 개수의 점을 움직여서 intersect가 전혀 일어나지 않도록 해야한다. 문제를 풀기 위해 점을 좌표 순으로 정렬한다. 그후 점의 인덱스로만 표현한 배열에서 increasing 후 decreasing 하는 가장 긴 subsequence를 구해주면 된다.

https://codeforces.com/contest/1519/problem/E
좌표 평면 상에 n개의 점이 있을 때, 두 개의 점 a, b를 골라 각각을 x축 또는 y축 방향으로 1 증가시킨 후 O, a, b가 일직선 상에 있다면 a, b를 제거하는 연산을 하려고 한다. 이 때 최대 연산 횟수를 구하는 문제다. 모든 점은 2개의 slope 중 하나로 옮겨진다. 점 p 이동 가능한 slope를 s1, s2라고 했을 때, s1과 s2를 그래프의 정점으로 표현하고, p를 s1과 s2를 연결하는 그래프 간선으로 표현한다. 2개의 점을 골라 지웠다는 것은 이 그래프에서 2길이 path를 의미한다. 2길이 path의 최대 개수를 구하기 위해서는 만들어진 그래프에서 tree dp를 수행하면 된다. dfs 트리 특성상 모든 간선은 dfs 트리 간선 또는 dfs 트리 간선에 속하지 않는 순방향 간선으로 표현할 수 있다. 트리 정점 x에서 2길이 path를 만들기 위해서는 순방향 간선 중, 매칭 되지 않는 2개의 간선을 골라 연결하면 된다. 그러한 간선이 1개 남았다면 부모로 가는 간선과 연결한다. 이 방법이 가능한 이유를 설명하자면, 특정 서브 트리 v를 봤을 때, v의 자식 노드에 달려있는 간선은 모두 매칭 되며, v에 연결된 간선 또한 모두, 혹은 1개를 제외하고 모두 매칭된다. 따라서 전체 그래프에 대해 모든 간선, 혹은 1개를 제외한 모든 간선이 매칭되게 되며, 구하고자 하는 답을 구할 수 있다. 매칭 문제는 꽤나 자주 그래프로 모델링 된다.

2021-05-04
https://www.acmicpc.net/problem/9587
sns 메시지들이 나열되었을 때, mention으로 연결된 가장 긴 대화를 찾는 문제이다. mention을 directed edge로 표현하면 전체 그래프가 DAG이므로, 단순히 dp를 수행해주면 되는 문제다. 나는 문제를 풀기 위해 message에 언급된 handle이 작성한 메시지 중 깊이 최대값을 찾기 위해 최근 메시지 1개만 확인했다. 하지만 이는 실수였고, 해당 handle이 작성한 메시지 중 깊이가 가장 깊은 메시지를 찾아야했다. 이는 순서대로 계산하면서 배열에 누적 계산해주면 된다.

https://codingcompetitions.withgoogle.com/codejam/round/00000000004362d7/00000000007c1139
최대 100길이의 bit string s와 e가 주어졌을 때, not연산과 double연산을 이용하여 s를 e로 바꾸는 것이 목표다. 만약 가능하다면 연산의 최소 횟수를 출력해야 한다. s에 사용된 비트를 아예 사용하지 않는 naive 방법과, s에 not 연산을 x번 적용했을 때 만들어진 bit string을 사용하는 방법을 고려해주면 된다. s에 not 연산을 x번 적용했을 때의 값을 s'라고 했을 때, s'는 e의 prefix이어야 하며, 해당 prefix를 제외한 e의 suffix에서 필요한 not의 횟수가 x보다 작거나 같아야 한다. suffix(ex. 0011001)에 필요한 not 횟수는 기본적으로 (값이 바뀌는 횟수) - 1회 필요하며, 마지막 bit가 1일 경우 추가로 1회 더 필요하다.

2021-05-05
https://www.acmicpc.net/problem/9588
board 위의 숫자를 플레이어들이 순서대로 자신의 패의 숫자로 변경하는 게임을 한다. 내 번호는 1번이고, 최종적으로 내 고유의 숫자가 board 위에 과반수 이상일 때 승리한다. 다른 플레이어들이 어떻게 동작하든지 상관 없이 무조건 이기는 동작을 모두 출력해야 한다. n=1일 때는 board 위의 숫자가 무조건 마지막 플레이어의 숫자로 변경된다. n>1일 때는 다른 플레이어들이 내 숫자를 최대한 지우고, 다른 숫자를 최대한 많도록 할 것이다. 내가 취할 수 있는 모든 동작 마다 무조건 이기는지 체크한다. best 2 색깔들만 기억하면 답을 구할 수 있다고 한다.

https://www.acmicpc.net/problem/9586
주어진 배열의 subarray 중 원소의 bitwise xor값과 bitwise and값이 같은 subarray의 개수를 구해야한다. subarray 의 시작점을 x로 고정해두고 생각해보자. 그러면 subarray의 and값의 개수는 32가지 밖에 없다. 동일한 and값을 가지는 구간을 1개의 구간으로 뒀을때, 해당 구간 내에 xor 값이 and 값과 같은 경우의 수를 부분 xor합 배열과 이분탐색을 이용하면 빠르게 계산할 수 있다. subarray의 시작점 x를 n에서 시작하여 1까지 줄여나가며 모든 경우의 수를 계산한다.

2021-05-07
https://codeforces.com/contest/1498/problem/D
처음엔 아무것도 없는 전자레인지를 돌렸을 때, 바나나를 1개, 2개, ... m개 만들기 위해 필요한 전자레인지 최소 가동 횟수를 구해야한다. 전자레인지 동작 방법 2가지 유형이 있는데, 하나는 현재 바나나 개수에 xi를 곱한 뒤 ceil 연산, 다른 하나는 xi를 더한뒤 ceil 연산이다. 동작 1회 마다 위에서 설명한 연산을 최대 m번 적용할 수 있기 때문에 단순히 계산하면 O(nm^2) dp가 된다. 하지만 연산 특성상 같은 단계에서 k 바나나를 만들었다면, 시작점이 어디이든 간에 다음 바나나 개수는 동일하므로 O(nm)으로 줄일 수 있다.

https://codeforces.com/contest/1498/problem/F
트리가 하나 주어진다. 루트가 정해져 있을 때, A와 B가 게임을 진행한다. 각 차례마다 플레이어는 깊이가 k이상인 정점을 골라, 그 점에서 양수 개수의 돌을 집어 k 단계 위의 부모에 올린다. 아무 동작도 하지 못하게 되는 플레이어가 게임에서 패배한다. Sprague-Grundy 이론에 따르면, 여러 개의 돌 더미에서 두 명의 플레이어가 번갈아가며 1개 더미에 양수 개수의 돌을 지우는 게임에서 승리하기 위해서는, 자기 차례에 각 돌 개수의 xor합이 0가 아니어야 한다. 0가 아닌 상태에서 무조건 0인 상태로 만들 수 있고, 0인 상태에서는 0가 아닌 상태로 밖에 전이될 수 없다. 이 이론을 문제에 적용해보자. 루트가 정해져 있을 때, 깊이를 k로 나눈 값이 짝수인 노드들은 신경쓸 필요 없다. 한 플레이어가 이 노드의 돌을 움직일 경우, 상대 플레이어도 움직인 돌을 짝수 위치로 옮기기 때문이다. 그렇다면 이번엔 k로 나눈 값이 홀수인 노드들을 살펴보자. 이 위치의 돌을 짝수 위치로 옮긴다는 것은 돌을 버리는 것과 같다. 따라서 홀수 위치의 돌에 대해 아까 설명한 게임을 적용해주면 된다. k는 최대 20이므로 tree dp를 이용하여 각 노드에서 (거리) mod 2k 값이 0, 1, 2, ... , 2K-1 인 노드들의 xor합을 계산하면 된다. 첫번 째 dfs로 서브트리에 대한 dp 값을 계산할 수 있고, 두번 째 dfs로 전체 그래프에 대한 dp 값을 계산할 수 있다.

게임이론에서는 승리 상태, 패배 상태를 정의하는 것이 중요한 것 같다. 승리 상태에서는 상대를 패배 상태로 만들 수 있어야 하고, 패배 상태에서는 무조건 승리 상태로 밖에 전이될 수 없어야 한다.

2021-05-09
https://codeforces.com/contest/1521/problem/D
트리 그래프가 주어졌을 때, 최소 개수의 간선을 제거한 뒤 같은 개수의 간선을 추가하여 전체 그래프를 1개의 path로 만들어야 한다. degree가 3을 넘는 정점이 없도록 먼저 간선들을 제거 한 뒤, 만들어진 path들을 1개로 이어주면 된다. 간선을 제거할 때는, 정점 1개를 root로 잡고 dfs하면서 순차적으로 제거한다. 그 방법은 서브트리 v에서 v의 자식들 먼저 degree가 2보다 작게 만들고 난 뒤, v의 degree가 2보다 크다면 부모로 이어지는 간선 먼저 제거한다. 자식들의 degree는 이미 2 이하이므로 부모의 degree를 1이라도 줄이는 게 이득이며, 트리에는 싸이클이 존재하지 않으므로 이와 같은 greedy가 동작하는 것으로 보인다. 트리에서의 maximum matching 또한 leaf부터 매칭 시키는 greedy solution이 존재하는데 비슷한 느낌이지 않나 싶다.

https://codingcompetitions.withgoogle.com/codejam/round/000000000019ffb9/00000000003384ea
코드잼 2020년 round2 1번 문제. 팬케이크가 2개의 스택에 L개, R개 쌓여 있다. i번 손님은 i개의 팬케이크를 원하는데, 두 개의 스택 중 크기가 큰 곳에서 팬케이크를 꺼내 준다. 크기가 큰 스택에 i개의 팬케이크가 없을 때 영업이 끝난다. 팬케이크를 나눠주는 과정이 2개의 phase로 이루어져 있다. 첫 번째는 한 쪽의 스택이 다른 한 쪽보다 월등히 많은 팬케이크를 가지고 있어서, 해당 스택에서만 팬케이크가 빠져 나가는 phase. 두 번째는 2개의 스택에서 팬케이크가 번갈아 빠져나가는 phase. 첫 번째 phase가 언제 끝나는지 binary search로 계산한 뒤, 각 스택에서 언제 바닥을 드러내는지 역시 binary search로 계산한다. test set 2의 경우 L과 R의 값이 굉장히 크다. 따라서 sqrt를 사용한 풀이는 sqrt의 오차를 조심해야하며, binary search를 사용한 풀이도 값의 범위를 잘 지정해줘야 한다. 코드잼의 경우 마지막 test set의 결과는 대회가 끝나고 나서 알려주기 때문에, 작은 실수로 등수가 내려갈 수 있다.

https://codingcompetitions.withgoogle.com/codejam/round/000000000019ffb9/000000000033871f
여러 개의 컴퓨터가 네트워크에 연결되어 있다. 소스 컴퓨터가 update를 받으면 네트워크 내의 모든 컴퓨터에 update를 전달한다. 각 컴퓨터는 update를 받는 즉시 인접한 컴퓨터에게 update를 전달한다. 간선의 가중치는 1 이상이다. 각 노드의 정보가 update를 받은 시간(T타입) 또는 해당 노드보다 먼저 update를 받은 노드의 개수(R타입)로 주어질 때, 각 간선에 임의의 가중치를 부여해야한다. R타입과 T타입의 노드를 각각 정렬한 뒤 순서를 지정할 수 있다. order 목록이 현재 대기중인 R타입 노드의 값보다 크거나 같다면 R타입을 order 끝에 추가할 수 있고, 그렇지 않다면 T타입의 노드를 order 끝에 추가한다. 그 후, R 타입의 노드에도 T 값을 부여할 수 있는데, 이전 컴퓨터와 동시에 update를 받야아 한다면 이전 컴퓨터와 같은 T값, 그렇지 않다면 이전 컴퓨터의 T값에 +1한 값을 부여한다. 귀납법으로 일어날 수 있는 모든 경우의 수에 대해 증명할 수 있다.

https://www.acmicpc.net/problem/16602
n개의 회의를 진행해야 한다. 회의 간에는 의존 관계가 존재하고, 각 회의마다 진행하는 데 걸리는 시간이 다르다. 단, i번째로 진행하는 회의는 i-1의 단위 시간이 추가로 걸린다. 이 때, 가장 오래 걸리는 회의의 진행 시간을 최소화한 값을 구해야 한다. 위상 정렬할 때 indegree가 0인 노드 중 1개를 다음 순서로 지정하게 되는데, 어떤 우선순위를 적용하여 최적의 노드를 지정하는 것이 문제 키포인트다. 처음 풀 때는 우선 순위 값을 해당 노드를 필요로 하는 노드 중 회의 시간 최대값으로 지정했다. 하지만 풀이를 보니 더 쉬운 방법도 있었다. 역순으로 위상 정렬을 하면서 노드의 -(회의 시간)을 우선순위로 두면, 최적의 순서를 구할 수 있다.

2021-05-10
https://www.acmicpc.net/problem/16603
정점의 개수가 최대 1000개인 트리 그래프가 주어졌을 때, 점을 좌표 평면 상에 배치 해야한다. 조건은 어떠한 간선도 다른 간선과 겹치지 않고, 모든 두 점 사이의 거리가 최소 1/10^4는 되어야 하며, 각 간선의 길이는 1 고정에 두 직선 사이의 거리는 최소 1/10^6 이어야 한다. 문제를 풀기 위해서는 정점들을 dfs 방문 순서로 배치를 하면 된다. 루트는 원점에 위치시키고, 이후의 정점 y좌표를 이전 배치한 정점 y좌표에 1/10^4 을 더한 값으로 고정시킨다. 그렇게 모든 간선이 서로 겹치지 않고, 모든 정점 사이의 거리가 1/10^4을 넘도록 만들 수 있다.

https://www.acmicpc.net/problem/16607
최대 20 길이의 일련의 동작이 주어 졌을 때, 해당 동작대로 공을 굴리는 게임을 만드려고 한다. 매 동작마다 공은 해당 방향으로 벽을 만날 때까지, 혹은 구멍을 만날 때까지 움직인다. 정확히 마지막 동작에 공이 구슬로 들어가도록 벽의 위치와 시작 지점을 지정해야 한다. 나는 문제를 풀 때 공의 이동 경로를 2배씩 늘려 최대한 경로가 겹치지 않도록 했다. 그 후, 시뮬레이션을 돌려서 조건대로 게임이 완성되었는지 확인했다. 이 문제는 조건을 충족하면서도, 쉽고, 정확한 문제 해결 전략을 요구하는 문제다. 풀이에는 경로를 최대한 겹치게 하지 않으면서도 쉽게 구현 가능한 다른 풀이가 있었는데, 변의 길이가 4 방향으로 2씩 늘어나는 정사각형 모양의 구역을 이용한 방법이었다. 이동 방향이 이전 이동 방향의 +-90도일 때만 다음 구역으로 이동할 수 있게 한다. 그렇게 만들기 위해 구역 외부에 블럭을 1개씩 양쪽으로 배치한다. 

2021-05-12
https://www.acmicpc.net/problem/16610
1:1 스포츠 경기를 n명이 관람하면서 베팅을 한다. 현재 Julia의 베팅 점수가 다른 관람객들보다 크거나 같다. Julia는 지금부터 다른 관람객들 중 점수가 가장 높은 관람객들이 가장 많이 뽑은 팀에만 베팅하는 전략을 취할 때, 최악의 경우 julia 가 선두를 유지하는 횟수를 구해야 한다. 각각의 포인트는 최대 10^16이므로 규칙을 찾아 빠르게 시뮬레이션 해야한다. Julia에게 최악의 경우는 t명의 차점자 중 ceil(t/2)명만이 잃는 베팅을 하는 것이다. 시뮬레이션을 돌려보면 차점자의 명수는 경기를 거듭할 수록 절반으로 줄어든다. 그러다 차점자가 1명이 된 이후 원래의 명수를 회복하는데, 그 다음 차점자와의 점수 차는 1 줄어든다. 만약 다음 차점자와의 점수차가 1이었다면 두 그룹은 합쳐진다. 차점자 그룹과 그 다음 차점자 그룹이 합쳐질 때까지 julia가 선두를 유지하는지 확인하고, 유지한다면 두 그룹을 합친 후 계속 계산하면 되고, 유지 못 한다면 정답을 계산 후 출력하면 된다.

https://www.acmicpc.net/problem/16601
n개의 점이 좌표 평면 위에 존재할 때, 순서대로 n개의 점을 설치 후 매칭시켜주려고 한다. 입력으로 주어진 i번째 점을 Ai(axi, ayi)라고 하고, i번째 새로 설치한 점의 좌표를 Xi(xi, yi)라고 했을 때, xi-1 <= xi && yi-1 <= yi 조건을 만족하면서 Ai와 Xi 간의 거리 제곱의 합을 최소로 만들어야 한다. 거리 제곱의 합은 sum(i=1~n){ (axi - xi)^2 + (ayi - yi)^2 } 으로 나타낼 수 있는데, x좌표 값과 y좌표 값이 서로 영향을 주지 않기 때문에 1차원으로 분리하여 문제를 풀 수 있다. x좌표에 대해서만 계산해보자. 입력된 점의 좌표가 a1, a2, ... an 이고, 새로 설치하는 점의 좌표가 x1, x2, ... xn일 때, sum(i=1~n){ (xi - ai)^2 } 를 최소화해야 한다. ai를 순서대로 보면서 xi를 추가하려고 한다. 만약 현재 설치하려는 점 xi가 xi-1보다 작다면 어쩔 수 없이 xi-1과 같은 점에 설치해야한다. 이 때, xi-1을 조절함으로써 구하고자 하는 값을 줄일 수 있다면 줄이는 게 좋다. sum(k=i~j){ (x-ak)^2 } 을 최소화하는 x의 값은 avg(k=i~j){ ak } 이다. 따라서 xi-1을 조절하려면 현재 고려 중인 점들 좌표값의 평균으로 조절해주면 된다. 스택을 이용해서 설치된 점들을 유지해주면 문제를 해결할 수 있다.

https://www.acmicpc.net/problem/16605
두 문자열이 주어졌을 때, 결과로 나올 수 있는 수열의 가능성이 모두 같은 지 계산하는 문제이다. 문자열에는 list를 제외하고 3개의 연산이 있다. concat은 합치는 연산이므로 신경쓰지 않아도 되고, sorted와 shuffle이 중요하다. 포함관계를 생각했을 때, shuffle 또는 sorted 된 것을 1개 이상 혹은 0개의 원소를 추가해서 다시 shuffle 또는 sorted 할 경우, 이전의 연산은 무시해도 된다. 따라서 가장 상위의 shuffled와 sorted를 체크 하여 두 문자열이 동등한지 확인한다. shuffle 내에 같은 원소만 있을 경우 무시해도 된다는 점을 주의하자. 풀이를 보면 sorted 연산은 배열을 non-decreasing 정렬, shuffle 연산은 배열을 non-increasing 정렬한 뒤, 단순히 배열의 값을 비교하여 동등 여부를 결정했다.

2021-05-13
https://codingcompetitions.withgoogle.com/codejam/round/0000000000051679/0000000000146183
원자 c, 원자 j가 1개 이상씩 포함되어 있는 분자 n개가 주어진다. n이 최대 300일 때, n개의 분자를 질량 strictly increasing order로 정렬하는 방법의 수를 계산해야한다. c와 j의 무게는 정해져 있지 않은데, 모든 경우의 수를 시도해보기엔 c와 j의 범위가 너무 크다. 실제 c와 j의 질량은 중요하지 않으므로 c, j의 비율 k=c/j 만을 생각해보자. 순서가 이미 정해져 있지 않은 모든 쌍의 분자를 비교했을 때, (a, b) 쌍의 질량 대소 관계가 반전되는 k 값은 (ca - cb)/(jb - ja)로 정해져 있다. 이 비율값을 지날 때마다 ordering이 바뀌게 되므로, 총 ordering의 개수는 서로 다른 비율 값의 개수 + 1이다. 소수점을 사용할 경우 오차가 발생할 수 있으므로 비율을 기약분수꼴로 만들어 저장해야한다.

2021-05-15
https://www.acmicpc.net/problem/9646
행과 열의 길이가 최대 7일 때, 주어진 다이어그램에 숫자를 채워넣는 방법의 수를 세는 문제이다. 단, 각 박스에는 1~N 사이의 숫자가 들어가야 하며, 각 박스에 적혀있는 정수는 왼쪽에 있는 정수보다 크거나 같아야 하고, 위에 있는 정수보다는 커야 한다. N의 값은 최대 7이다. 완전 탐색을 이용하여 풀 수 있다고 한다. 단 가지치기를 잘 해야한다고 하는데, 직접 풀어봤을 때는 TLE를 면하기 어려웠다. 각 행마다 dp를 적용할 수도 있다. 각 행마다 나타날 수 있는 경우의 수는 7^7 = 823543이다. 모든 행에 dp를 적용하기 보다는 2번째 행에만 dp를 적용하여 풀었다.

2021-05-16
https://codeforces.com/contest/1504/problem/E
1번 도시에서 모든 도시를 1번 씩만 방문한 뒤 다시 1번으로 돌아오는 최단 경로를 구해야 한다. i번 도시에서 j번 도시로 가는 경로의 비용은 max(ci, aj - ai)이다. 문제를 풀기 위해서는 도시를 ai 순으로 정렬한다. 경로가 하나의 싸이클이기 때문에 출발 도시가 바뀌어도 문제가 바뀌지 않는다. 모든 도시를 1번은 방문해야하기 때문에 ci의 합은 기본적으로 들어간다. 따라서 각 경로에서 ci를 제외한 max(0, aj - ai - ci) 합이 최소값을 구한 뒤, ci의 합을 더해주면 구하고자 하는 답이 된다. ai >= aj 인 j번 도시로 이동하는 데 드는 비용은 0이므로 1번 도시에서 n번 도시로 가는 최단 거리가 우리가 구하는 경로의 최소 비용이 된다. 그 이유는 1번 도시에서 n번 도시로 가는 동안 방문하지 않은 도시는 ai의 역순으로 방문함으로써 비용을 들이지 않고 방문할 수 있기 때문이다. 1번 도시에서 n번 도시까지의 최단 경로를 다익스트라로 구하면 된다. 이 때 간선의 개수는 문제 그대로 구현 시 O(N^2)개이지만, 최단 경로에 사용되는 간선의 개수는 최대 O(N) 밖에 되지 않는다. 현재 도시 i에서 i-1 도시로 가는 비용 0 경로, 현재 도시 i에서 비용 0으로 갈 수 있으면서 가장 큰 idx를 가지고 있는 j 도시로의 경로, 마지막으로 j + 1로 가는 경로. 위 3개의 경로만 있으면 1번 도시에서 n번 도시로 가는 최단 경로를 구할 수 있다.

2021-05-18
https://codeforces.com/contest/1492/problem/E
n개의 배열이 주어진다. 초기에는 모든 배열이 똑같았으나, 사고로 인해 각 배열마다 최대 2개의 원소 값이 바뀌었다. 사고 이후의 배열들이 주어졌을 때, 초기의 배열을 찾아내야 한다. 만약 조건을 만족하는 배열이 여러 개라면 아무거나 출력하면 되고, 조건을 만족하는 배열이 없다면 No를 출력해야 한다. 문제를 풀기 위해 1번 배열의 원소 2 이하 개수를 바꾸어서 답을 구하고자 한다. 1번 배열과 원소 3개 또는 4개 다른 배열을 찾는다. 값이 다른 원소들을 제외하고는 모두 초기 배열의 값을 유지하고 있을 것이다. 따라서 1번 배열에서 해당 원소들의 값을 최대 2개 변경하여 문제를 풀 수 있다. 변경하려는 인덱스를 와일드카드로 지정한다. 와일드카드는 많을 수록 좋으므로 무조건 2개를 지정해줘도 상관 없다. 와일드카드를 지정한 후, n개의 배열을 모두 확인하며 1번 배열과 값이 다른 원소의 개수를 센다. 현재 배열이 1번 배열과 와일드 카드를 포함하여 값이 3개 이상 차이난다면 와일드 카드를 사용해야 한다. 그렇지 않다면 어떤 동작도 취하지 않고 다음 배열로 넘어간다. 이와 같은 방식으로 1번 배열을 수정하여 다른 배열을 2개 이하 차이나도록 만드는데 성공했다면 답을 출력한다. 실패했다면 조건을 만족하는 배열이 없다는 뜻이므로 No를 출력한다. 1번 배열에서 와일드카드를 지정하는 경우의 수는 최대 6가지이며, n개의 배열을 확인하는 과정에서 와일드카드를 1개 이상 사용해야하는 경우는 최대 2번 발생한다. 3번부터는 와일드 카드가 존재하지 않기 때문이다. 따라서 총 시간 복잡도 O(n*m)만에 문제를 해결할 수 있다.

2021-05-19
https://codeforces.com/contest/1438/problem/E
최대 20만 크기의 배열 arr가 주어진다. good subarray의 개수를 구해야 한다. good subarray란 길이가 3 이상이며, 양쪽 원소의 xor 값이 그 외의 원소의 합과 같은 subarray를 말한다. 문제를 풀기 위해서는 먼저 왼쪽 끝 원소를 l로 고정시켰을 때, r을 l+2에서 점점 늘려가며 사이의 원소 값의 합 sum이 arr[l]^arr[r]과 같은지 확인한다. 만약 도중에 sum의 msb가 arr[l]의 msb를 넘었을 때는 반복문을 종료한다. 같은 방식으로 배열을 뒤집어 다시 계산한다. 이러한 brute force가 동작하는 이유를 간단히 설명해보자. 어떠한 r에 도달할 수 있는 l의 개수는 O(log arr[i])개로 굉장히 적다. 어떠한 k에 대해서 msb가 2^k 인 원소 중 r에 도달할 수 있는 원소의 개수는 최대 2개이기 때문이다. r의 개수는 O(n)이므로 분할 상환되어 총 시간 복잡도 O(n log a[i]) 만에 문제를 해결할 수 있다.

2021-05-20
https://codeforces.com/contest/1421/problem/D
정육각형 모양의 타일이 깔린 평면에서 6개의 방향으로 이동할 때 드는 비용이 주어졌을 때, 어떤 좌표로 이동하는 데 드는 최소 비용을 구하는 문제이다. 문제 해결을 위해서는 2개의 이동만으로도 충분하다. 만약 서로 반대 방향인 두 이동이 사용되었을 경우 상쇄 가능하므로 최적이 아니다. 이렇게 고를 수 있는 이동 방향의 수는 총 3개인데, 여기서 1개의 이동을 더 줄일 수 있다. 현재 선택지에서 c1, c2, c3가 남았다고 하자. c1 + c3는 c2와 같은데, c1 + c3와 c2 중 어떤 것이 더 값싼지에 따라 c1 + c3를 c2로 바꾸거나 c2를 c1 + c3로 바꿀 수 있다. 따라서 c1 또는 c3가 모두 없어지거나 c2가 모두 없어지므로, 최종적으로는 2개의 이동만이 남게 된다.

https://codeforces.com/contest/1421/problem/E
n 크기의 배열이 주어졌을 때, 인접한 2개의 원소를 ai, ai+1를 골라 제거한 뒤 그 자리에 -(ai + ai+1) 원소를 넣는 작업을 반복한다. n-1 번의 작업 후에 남은 원소의 최대값을 구하는 문제이다. 풀이를 온전히 이해하지 못 했지만, 간단히라도 설명을 남겨보고자 한다. 최종 결과는 각 원소에 - 또는 +를 적용한 뒤 합을 구한 값이다. 단순히 이 방식을 적용하려고 했을 때는 음수인 원소에만 -를 적용하려고 하겠지만 몇가지 조건이 더 필요하다. 먼저 -와 +가 번갈아 나타나는 패턴은 불가능하다. 그 이유는 처음에 선택된 2개의 원소는 반드시 같은 부호를 가지기 때문이다. 또한 배열의 길이(n)와 -를 적용한 원소의 개수(m)를 더한 값(n+m)은 3으로 나누었을 때 나머지가 1이어야 한다. 이 조건에 대한 설명을 이해하진 못 했다. 위 2가지 조건을 충족했을 때 얻을 수 있는 최대값은 정렬 후 시뮬레이션, 또는 dp로 구할 수 있다.

https://codeforces.com/contest/1527/problem/D
트리 그래프가 주어졌을 때, mex값이 0, 1, 2, 3, ..., n인 경로의 개수를 출력해야하는 문제다. 우리가 구하고자 하는 값을 ans(0), ans(1), ..., ans(n)이라고 하자. 그리고 mex값이 i 이상인 경로의 개수를 pcnt(i)라고 하자. 그러면 ans(i) = pcnt(i) - pcnt(i+1)이 성립한다. pcnt(0)은 nC2 이며, pcnt(1)은 트리 dp를 이용하여 ans(1)를 계산한 후 pcnt(0)에서 빼줌으로써 구할 수 있다. 그 이후의 pcnt는 투포인터 방식을 이용해서 계산해준다. 0번 정점부터 i번 정점까지 모두를 포함하는 path의 양 끝을 l과 r이라고 하자. 그러면 pcnt(i+1)은 (l의 서브트리 크기) * (r의 서브트리 크기) 로 쉽게 구할 수 있다. 이후 i+1번 정점을 연결하기 위해서는 i+1번 정점에서 path를 만날 때까지 계속 상위 노드로 올라가면 된다. 그 이유는 l ~ r path는 트리의 루트인 0번 정점을 반드시 포함하고 있기 때문에 i+1번 정점은 path에 이미 포함 되어있거나 path의 정점들 중 하나의 서브트리에 속해있을 수 밖에 없다. 만약 상위 노드로 계속 올라왔는데 l, r 외의 path 정점을 만났다면, 0~i+1 정점들을 모두 포함하는 path가 존재하지 않기 때문에 pcnt(i+2) 는 0이다. pcnt를 모두 계산해준 뒤 ans를 출력하면 풀이는 끝이 난다.

2021-05-22
https://codeforces.com/contest/1497/problem/C2
n과 k가 주어졌을 때, k길이의 배열을 만들어야한다. 단, 모든 원소의 합은 n과 같아야 하며, 모든 원소의 LCM 값은 n/2보다 작거나 같아야한다. k=3일 때의 문제가 C1인데, 홀수일 때는 (1, (n-1)/2, (n-1)/2)로 가능하고, n이 짝수이나 4로 나누어 떨어지지 않을 때는 (2, (n-2)/2, (n-2)/2)로 가능하고, n이 4로 나누어 떨어질 때는 (n/2, n/4, n/4) 로 가능하다. c2 문제로 돌아와서 k가 3보다 클 경우, 3보다 큰 만큼 원소 1을 추가하고 n에서 1을 뺀다. 이후 남은 3자리의 값을 구하기 위해, 현재 n에 대하여 c1 풀이를 적용해주면 된다. c1은 풀었으나 c2를 풀지 못했는데, 대회 중에 불필요한 감정이 많아 집중하지 않았다고 본다.

https://codeforces.com/contest/1497/problem/E2
n길이의 배열이 주어졌을 때, 배열을 최소 개수의 연속된 부분 배열로 분할하려고 한다. 이 때, 각 부분 배열에서 2개의 원소를 곱했을 때 완전 제곱수가 되지 않아야 한다. 각 원소를 소인수 분해하여 열거했을 때, 같은 값을 가진 소인수를 2개씩 짝지어 제거해주자. 새로 만들어진 배열을 b라고 했을 때, b에서 서로 다른 원소를 곱했을 때 완전 제곱수가 되려면 그 2개의 원소 값이 같아야 한다. 따라서 이 문제는 배열 b를 서로 다른 원소 값들을 가지는 연속된 부분 배열로 쪼개는 문제가 된다. 문제를 풀기 위해서는 먼저 left(i, j)를 구한다. left(i, j) = l 이라고 했을 때, l은 arr[l...i]에 j번 값을 변경했을 때 부분 배열 arr[l...i] 원소 값이 서로 다르게 되는 최소 인덱스 값이다. left 배열은 two pointer를 이용해서 O(n*k) 만에 구할 수 있다. 이후 정답을 구하기 위해 dp를 적용한다. dp(i, j)는 arr[1...i]에 j번 값을 변경했을 때 가능한 최소 분할 개수이다. 점화식은 dp(i, j) = min(c=0~j){ dp( le(i, c) - 1, j-c) + 1 } 가 된다. 만약 i가 0이라면 dp(i, j) 값은 0으로 두면 된다.

2021-05-23
https://codeforces.com/contest/1483/problem/C
n개의 건물이 있을 때, 건물들의 사진을 찍어서 사진 아름다움의 합을 최대로 하려고 한다. 이때 모든 건물들은 사진에 정확히 1번씩 등장해야 하며, 한 사진에 있는 건물들은 연속된 인덱스를 가져야 한다. 사진 1개의 아름다움은 사진에 속한 건물 중 가장 낮은 건물의 아름다움과 같다. 문제를 풀기 위해서 O(n^2) dp를 생각할 수 있다. dp(i)를 1~i의 빌딩으로 얻을 수 있는 최대 아름다움 합으로 둔다. dp(i) = max(j=0~i-1) { dp(j) + b(j+1, i) }. 이 때, i 보다 왼쪽에 있는 건물 중 높이가 i보다 낮으며 가장 가까운 건물의 인덱스를 k라고 하면 k 이전의 dp값들은 신경쓰지 않아도 된다. dp(k)에 이미 누적되어 계산되어 있기 때문이다. j가 [k+1, i-1] 구간일 때는 b(j+1, i) 값은 항상 b(i)이기 때문에 해당 구간의 dp 최대값만 빠르게 계산해 주면 된다. 이를 max 구간 쿼리가 가능한 세그먼트 트리를 사용하여 풀 수 있다. 구현에 있어서 i 보다 높이가 낮은 가장 가까운 건물을 찾기 위해서는 스택을 사용하면 된다. 현재 건물의 높이보다 스택 top에 있는 건물의 높이가 더 크다면 계속 pop을 해준다. pop이 끝났을 때 스택이 비어있다면 i보다 낮은 건물이 i 왼쪽에 존재하지 않는다. 비어있지 않다면 top에 있는 빌딩이 i 보다 높이가 낮은 가장 가까운 건물이 된다. 이 스택을 이용하면 세그먼트 트리 역시 사용하지 않고 문제를 해결할 수 있다 스택 노드에는 높이와 인덱스 외에도 dp 구간최대값을 저장하자. 이 때의 구간최대값은 해당 건물 이후 삭제된 건물 인덱스 dp 값들 중 최대값을 유지한다. 현재 인덱스 dp값을 구하기 위해서는 pop이 끝난 후의 스택 top의 구간최대값을 확인해주면 된다.

https://codeforces.com/contest/1525/problem/D
최대 5000개의 의자가 있다. 의자의 개수가 n일 때, 최대 n/2의 사람이 서로 다른 의자에 앉아 있다. 의자에 앉은 사람들을 1명씩 이동 시켰을 때, 초기에 사람이 앉았던 의자들이 모두 비어있도록 만들기 위한 최단 시간을 구해야한다. 이 때, i에 앉아 있던 사람이 j로 이동하는 데 걸리는 시간은 abs(i-j)이다. 사람이 앉아 있는 의자의 좌표를 x1, x2, ... 라고 하고, 사람이 앉아 있지 않은 의자의 좌표를 y1, y2, ... 라고 하자. 각 좌표 리스트가 정렬되어 있을 때, 정렬된 순서대로 매칭 시키는 것이 항상 최적이다. 만약 x1->y2, x2->y1 매칭이 둘다 오른쪽 또는 왼쪽 방향으로 이동하는 것이라면 x1->y1, x2->y2로 바꾸어도 이동 거리의 합은 변함없다. x1->y2, x2->y1 매칭의 이동 방향이 서로 다를 경우, 이동 경로에 겹쳤던 부분이 x1->y1, x2->y2 매칭으로 바꿨을 때 사라지게 되므로 소요 시간을 단축시킬 수 있다. 따라서 사람이 앉은 의자와 빈 의자는 정렬 순서대로 매칭시키는 것이 최적이다. 마지막으로 문제를 해결하기 위해서는 dp를 적용한다. dp(i, j)를 1~i번 의자에 앉아 있는 사람을 1~j번 의자로 이동시켰을 때 최단 시간이라고 두자. dp(i, j)에서 j+1 의자를 비워둘 경우 dp(i, j+1) <- dp(i, j)로 전이되고, i+1번 의자를 j+1번 의자와 매칭 시킬 경우 dp(i+1, j+1) <- dp(i, j) + cost(i+1, j+1)로 전이된다. 총 시간 복잡도 O(N^2)으로 문제를 해결할 수 있다.

2021-05-24
https://codeforces.com/contest/1525/problem/E
n개의 도시가 있고, m개의 점이 있다. n번의 턴 동안 각 도시에 시설물을 1개씩 설치하여 m개의 점을 통제하고자 한다. x 턴에 설치된 시설물은 n 턴 이후 n-x+1 거리 이내의 점을 통제한다. 시설물을 설치하는 도시의 순서가 랜덤일 때, 통제할 수 있는 점의 개수 기대값을 구해야 한다. 이 문제를 풀기 위해서는 각 점마다 점령될 확률을 구해준 뒤 모두 더해주면 된다. 임의의 점 j가 점령될 확률은 1-(점 j가 점령 안 될 확률)과 같다. 그리고 점 j가 점령 안 될 확률은, 시설물 설치 순서를 순열로 나타냈을 때 (j가 점령 안 되는 순열의 개수) / n! 과 같다. j가 점령 안되는 순열의 개수를 구하기 위해서는 점 j와의 거리 d(i, j) 순으로 정렬 하여 순서대로 자리를 채워주면 된다. 점 j와 거리가 d(i, j)인 도시 i는 순열 상 끝 쪽에 d(i, j)-1 개의 후보 자리가 있다. 하지만 이전의 도시에 의해서 그 자리가 일부 찼을 경우 후보 자리가 줄어든다. 이를 유념해서 계산해주면 j가 점령 되지 않는 순열의 개수를 구해줄 수 있다.

2021-05-25
https://codeforces.com/contest/1528/problem/B
2*n개의 점이 주어지고, 2개 씩 짝을 지어주려고 한다. x와 y를 짝지은 것을 하나의 세그먼트로 표현하면 총 n개의 세그먼트가 생긴다. 이 때, 모든 2개의 세그먼트 쌍이 길이가 같거나, 하나가 다른 하나를 완전히 포함해야한다. dp를 이용하여 문제를 풀 수 있는데, 1번 점이 어떤 점과 페어링 되었냐에 따라 케이스를 분류할 수 있다. 1번 점이 k=n+2 이상인 점과 짝지어졌다면 k+i인 점은 1+i인 점과 반드시 페어링 되어야 한다. 2*n 점까지 페어링이 끝나고 나면 중앙에 공간이 생기는데 이 공간은 다시 dp를 통해 경우의 수를 구해준다. 1번 점이 k=n+1 이하인 점과 짝지어졌다면 중앙에 공간이 생기지 않으므로, 모든 세그먼트는 같은 길이를 가져야 한다. 그 길이를 len이라고 했을 때, 모든 점들이 len길이를 가지며 짝지어지려면 len이 n의 약수여야 한다. i=1~n의 약수의 개수를 구하기 위해서는 일일히 div=1~n까지 돌리면서 cnt[div*k]를 증가시켜주면 된다. 약수의 개수를 구하기 위해 사용되는 연산 횟수는 n * (1/1 + 1/2 + 1/3 + ... + 1/n) 으로, 시간복잡도는 O(nlogn)이 된다.

https://codeforces.com/contest/1528/problem/C
S 트리에서는 조상 관계에 있고, K 트리에서는 조상 관계가 아닌 u, v를 새로운 그래프에서 간선으로 연결해준다. 완성된 새 그래프에서 clique의 최대 크기를 구해야 한다. 완성된 clique에 속한 정점들은 S 트리에서는 루트에서 시작하는 한 path에 모두 속하고, K 트리에서는 어떤 두 정점도 루트에서 시작하는 한 path에 속하지 않아야 한다. 이 문제를 풀기위해서는 삽입, 삭제가 가능하고 현재 삽입된 정점들 중 K 트리 상에서 서로 조상 관계가 아닌 최대 크기 subset을 구할 수 있는 자료구조가 필요하다. 이 자료구조가 있다면 S 트리에서 dfs를 하면서 새로운 정점에 도착하면 그 정점을 삽입한 뒤 쿼리하고, 현재 정점에서 빠져 나갈 때는 자료구조에서 정점을 삭제하는 연산을 해줌으로써 답을 구해낼 수 있다. 자료구조를 구현하기 전에 먼저 K 트리를 dfs하면서 방문 순서대로 번호를 매긴다. 이 때, 한 서브트리 내의 정점들은 반드시 연속된 번호를 가지게 된다. 서브트리의 루트가 u일 때, l[u] = 자신이 가진 번호, r[u] = 서브트리 내의 정점이 가진 번호 중 가장 큰 값으로 둔다. 자료구조는 set< pair<int,int> > 로 구현이 되는데, 첫 번째 정수는 현재 정점의 방문 순서 번호이고, 두 번째 정수는 정점의 원래 번호이다. 현재 정점 now를 넣기 전에 set에 {l[now], now} 보다 큰 값이 존재하는 지 물어본다. 쿼리 결과에 따라 set에 이미 자손 정점이 있다면 현재 정점은 필요 없고, 조상 정점이 있다면 조상 정점을 제거하고 now 정점을 삽입해준다. 조상 정점을 제거할 때 주의할 점은 now 정점을 뺄 때 조상 정점을 다시 넣어 줘야한다. 

2021-05-27
https://codeforces.com/contest/1428/problem/E
당근의 개수 n, 토끼의 마리수 k가 주어진다. 그리고 n개 당근의 길이가 주어진다. n개의 당근을 총 k개의 조각으로 나눴을 때, 각 토끼가 당근을 모두 먹는 데 드는 비용을 최소화 해야한다. 이 때, 토끼 1마리가 x길이의 당근을 먹으려면 x^2의 비용이 들어간다. 만약 1개의 당근에 대해서 p조각으로 쪼갤 경우, 각 길이는 임의의 값 w에 대해 w또는 w+1이어야 한다. 어떠한 두 조각의 길이가 a, b이고 a+2 <= b를 만족할 경우, 해당 두 조각의 길이를 a+1, b-1로 바꾸는 것이 이득이기 때문이다. 이 때 w값은 당연히 floor(l/p)이 된다. f(l, p)를 l길이 당근을 p조각으로 나눴을 때 필요한 비용이라고 하자. 그러면 f(l, p-1) - f(l, p) >= f(l, p) - f(l, p+1)을 만족한다. 바꿔 말하면 하나의 당근을 쪼개면 쪼갤수록 비용 절감 효율이 떨어진다. f(2l, 2p) = f(l, p)*2를 만족한다. 왜냐하면 f(2l, 2p)에서 조각의 개수(2p)는 짝수이고, 당근의 길이(2l)도 짝수이므로 2l을 2p로 나눈 나머지 역시 짝수가 되어, w+1 길이의 조각, w 길이의 조각 모두 짝수 개수가 되기 때문이다. 그리고 f(l, p-1) + f(l, p+1) >= f(2l, 2p)를 만족한다. 왜냐하면 좌변 역시 2l길이 당근을 2p로 나누는 꼴인데, f(2l, 2p)가 2l 길이의 당근을 2p 조각으로 나누는 최소 비용이므로 좌변은 우변과 같거나 우변보다 클 수 밖에 없다. 두 식을 연립하면 f(l, p-1) + f(l, p+1) >= f(l, p)*2이므로, 정리하면 f(l, p-1) - f(l, p) >= f(l, p) - f(l, p+1)가 된다. 마지막으로 당근마다 컷을 추가했을 때 절감할 수 있는 비용을 우선순위큐로 관리하면 O(klogn)만에 답을 계산할 수 있다.

2021-05-29
https://codeforces.com/contest/1526/problem/C2
n개의 포션을 일렬로 나열되어 있다. i번째 포션을 먹었을 때 체력이 a(i) 증가하며, 체력이 음수가 되지 않고 먹을 수 있는 최대 포션 개수를 구해야 한다. 처음 체력은 0이다. 먼저 O(n^2) dp로 풀 수 있다. dp(i, k)값은 1~i 번 포션 중에 k개의 포션을 먹은 후 최대 체력이다. O(n log n)으로 풀기 위해서는 그리디 솔루션을 사용한다. c(i) = {a(i), i} 라고 했을 때, c(i) 역순, 즉 a(i)이 다르다면 a(i) 값이 큰 것 부터, a(i) 값이 같다면 인덱스 i 값이 큰 것부터 고려한다. 만약 i번 포션을 먹을 수 있다면 먹으면 되고, 그렇지 않다면 먹지 않으면 된다. 이러한 방법이 가능한 이유는 c(i) < c(j) 이고 현재 먹은 포션 집합에 i가 들어가 있지만 j가 들어가 있지 않다면 i를 j로 교체해도 되기 때문이다. 현재 포션을 먹어도 되는지 확인하기 위해서는 lazy propagation이 가능한 세그먼트 트리를 사용하면 된다. O(n log n)으로 동작하는 또다른 그리디 솔루션이 있다. 포션을 왼쪽에서 오른쪽으로 보면서, 지금까지 먹은 포션의 리스트를 우선순위큐로 관리한다. 그리고 현재 포션을 먹을 수 있다면 먹고, 먹을 수 없다면 큐에 있는 포션 값들 중 현재 포션 값보다 작으면서 음수인 포션이 있는지 확인한다. 만약 그러한 포션이 있다면 교체해줄 수 있다. 이를 증명하기 위해서 현재 목록 중에 k개의 포션만 먹어서 최대 체력을 만드는 문제를 생각해보자. 이 문제를 해결하기 위해서는 목록 중에 가장 큰 값을 가진 k개를 먹으면 된다. 따라서 새 포션을 고려할 때는 지금 껏 먹은 포션과 현재 포션 중 가장 값이 낮은 포션을 제외해야 한다.

https://codeforces.com/contest/1526/problem/D
최대 10만 길이의 문자열 t가 주어진다. t를 치환하여 s를 만들었을 때, s를 다시 t로 되돌리는 최소 이동 횟수를 최대로 만들어야 한다. 이 때, 한 번의 이동에서는 인접한 두 글자의 위치를 바꿔줄 수 있다. 문제 조건을 만족하는 최적의 문자열에서는 어떤 종류의 글자 모두가 연속하여 등장한다. c(i)를 s 문자열에서 연산이 끝난 후 t 문자열 상의 s(i)의 위치라고 했을 때, s를 t로 바꾸는 최소 이동 횟수는 c의 inversion 개수와 같다. 만약 s 문자열이 xxxAA...AA[A]xx...xx[A]AA...Axxx 의 꼴이라고 하자. 이 때, [A] 둘 중 하나를 다른 하나의 옆으로 이동시켜도 문제 없음을 보일 수 있다. 왼쪽의 [A]의 위치를 i, 오른쪽의 [A]의 위치를 j라고 했을 때, i가 j 옆으로 가는 동안 추가되는 inversion 수를 D1, j가 i 옆으로 가는 동안 추가 되는 inversion 수를 D2라고 하자. 그러면 D1 + D2 >= 0을 만족한다. D1 + D2 < 0 이라면 임의의 k에서 C(k) < C(i) 이고, C(j) < C(k)를 만족해야 하는데, 이것은 C(j) < C(i)를 의미하므로 모순이다. 따라서 어떤 종류의 알파벳이 서로 떨어져 있다면 이동 수의 손해 없이 합쳐줄 수 있다.

https://codeforces.com/contest/1499/problem/D
자연수 c, d, x가 주어진다. 이 때, c*lcm(a,b) - d*gcd(a,b) = x를 만족하는 a,b 쌍의 개수를 세야한다. a = gA, b = gB로 둔다. g는 gcd(a,b)이며, gcd(A,B) = 1이다. 그러면 주어진 식을 g(cAB - d) = x로 정리할 수 있다. g에 x의 약수를 하나씩 대입해주면 cAb - d의 값이 정해진다. AB = X 값을 만족하며 서로소인 A, B 쌍의 개수는, X가 가지는 서로 다른 소인수의 개수를 cnt라고 했을 때 2^cnt가 된다. x의 약수의 개수를 구하기 위해서는 단순히 1부터 sqrt(x)까지의 수를 x에 나눠보면 된다. 소인수 분해후 brute-force로 약수를 구할 수도 있으나 시간 차이가 거의 나지 않고, 구현은 더 어렵다. X가 가지는 서로 다른 소인수의 개수 cnt는 전처리로 구해주는게 좋다. 여러 개의 테스트케이스로 이루어져 있기 때문에 매번 직접 소인수 분해를 하게될 경우 시간 복잡도에 log(x)가 더 붙게 된다. 앞서 설명한 방식대로 구현할 경우 O(sqrt(x)) 만에 문제를 해결할 수 있다.

2021-06-03
https://codeforces.com/contest/1499/problem/E
최대 길이 1000인 문자열 x, y가 주어진다. subsequence x[l1, r1], y[l2, r2]을 하나의 문자열로 합치려고 한다. 이 때, 합쳐진 문자열에는 인접한 두 글자가 모두 달라야 한다. 모든 subsequence 쌍에 대해, 주어진 조건을 만족하면서 합치는 경우의 수의 합을 구해보자. dp를 이용하면 이 문제를 해결할 수 있다. dp(i, j, last, xvis, yvis)를 모든 가능한 시작점 (l1, l2)에 대해 r1=i, r2=j인 subsequence를 합쳤으며, 마지막엔 last 문자열의 문자가 위치할 때의 경우의 수 합으로 둔다. xvis가 1일 경우 x 문자열에서 1개 이상의 글자를 가져 왔으며, yvis가 1일 경우 y 문자열에서 1개 이상의 글자를 가져 왔음을 의미한다. 모든 시작점에서의 결과를 저장하기 위해서는 모든 i, j에 대해 dp(i, j, 0, 1, 0)과 dp(i, j, 1, 0, 1)에 1을 더해주면 된다. 이 연산의 의미는 현재 위치에서 x 또는 y에서 1글자를 취한 경우의 수 1을 추가하는 것이다. xvis와 yvis를 상태 정의에 추가한 이유는 x 또는 y의 subsequence가 빈 문자열인 경우를 정답에서 제외하기 위함이다.

2021-06-05
https://codeforces.com/contest/1535/problem/E
루트가 있는 트리 구조의 그래프에서 주어진 쿼리를 처리해야한다. i번 정점은 a(i)의 골드를 가지고 있고, i번 정점에서 골드 1톤을 구매하는데 드는 비용은 c(i)이다. 초기에는 0번 정점만이 존재한다. 쿼리에는 2가지 종류가 있는데, 1번 쿼리는 i번 정점을 pi 정점 아래에 추가하는 쿼리이고, 2번 쿼리는 루트에서 vi 정점까지의 경로 상의 정점에서 wi 톤의 골드를 최소 비용으로 구매하는 쿼리이다. 2번 쿼리의 결과를 online으로 출력하지 않으면 다음 쿼리를 제공하지 않기 때문에, 1번 쿼리를 미리 처리한 후 2번 쿼리를 처리하는 offline 풀이를 사용할 수 없다. 문제의 조건에 의해 c(i) > c(pi)이다. 즉, 골드를 최소 비용으로 구매하려면, 경로 상의 정점 중 루트와 가까운 정점의 골드부터 구매하는 게 이득이다. 하지만 v 정점에서 골드를 구매하고 나면 그만큼 골드가 없어지기 때문에, 어느 정점에 골드가 남아있는지 빠르게 계산해야한다. 이를 위해 sparse table을 사용한다. parent(i, k)는 i번 정점에서 2^k 단계 위에 있는 정점 번호를 의미한다. i번 정점 골드가 남아있지 않다면 parent(i)번 정점에도 골드가 남아있지 않을 것이다. 따라서 sparse table을 이용하면 골드가 남아있는 가장 상위의 정점을 O(log(q))만에 찾을 수 있다. 현재 쿼리의 목표 골드량을 채울 때까지 골드가 남아있는 정점을 찾고 골드를 구매하는 연산을 반복해주면 된다.

https://codeforces.com/contest/1439/problem/B
n개의 정점, m개의 간선이 있는 그래프가 주어진다. 해당 그래프에서 크기가 k인 clique 또는 subset 내의 각 정점이 subset 내에 최소 k개의 이웃을 가지는 subset을 찾아야 한다. 문제를 풀기 위해서는 각 정점을 이웃의 개수 순서대로 탐색한다. 이웃의 개수가 k-1 미만인 정점들을 필요 없으므로 그래프에서 제거한다. 이웃의 개수가 현재 k-1인 정점이 있다면 이 이웃들로 k크기 clique가 만들어지는지 확인한다. 만약 clique가 된다면 출력하고, 실패하면 해당 정점 역시 제거한다. 남은 정점 모두가 k개 이상의 이웃을 가진다면 구하고자 하는 subset을 찾았으므로 그대로 출력한다. 모든 정점이 제거될 경우 clique와 subset 둘 다 존재하지 않으므로 -1을 출력한다. 문제를 푸는 데 가장 많은 시간이 걸리는 부분이 clique 확인이다. unordered_set을 사용하면 O(k)개의 이웃 모두 서로 간선으로 연결되어 있는지 확인하기 위해 O(k^2)의 시간이 걸린다. 하지만 새로운 clique 후보를 확인할 때마다 k-1개의 간선을 지우게 되므로, clique의 후보 개수는 O(m/k)개이며, amortized O(mk) 시간만에 모든 clique 후보를 확인할 수 있다.

2021-06-06
https://codeforces.com/contest/1535/problem/C
0, 1, 또는 ? 로 이루어진 문자열 s가 주어졌을 때, beautiful한 substring의 개수를 구하는 문제이다. substring이 beautiful하려면 substring에 속한 ? 각각을 0 또는 1로 바꾸었을 때 완성된 문자열이 0과 1이 반복된 형태여야 한다. 문제를 풀기 위해서는 beautiful한 substring을 쪼갤 경우, 쪼개어진 substring들 역시 beautiful 하다는 걸 이용한다. s 문자열의 어떤 지점 r에 대하여, r에서 끝나는 beautiful 하지 않은 substring 중 시작 지점 l이 가장 큰 것을 구한다. 이 때, 시작 지점이 [l+1, r]에 속할 경우 substring이 beautiful하게 되므로 r에서 끝나는 beautiful substring의 개수는 r-l이 되며, 모든 r에 대해 r-l을 다 더해주면 정답을 구할 수 있다. l을 구하기 위해서는 lst 배열을 사용한다 lst(v, p)의 값은 r 이전에 v값이 패리티 p에 등장한 가장 최근 인덱스 값을 의미한다. 현재 패리티가 p이고 현재 숫자가 0라면 l = max(lst(0, p^1), lst(1, p))가 될 것이다. r의 값을 1부터 slen까지 증가시키면서 lst 배열을 관리해주면 O(slen)만에 문제를 해결할 수 있다.

2021-06-08
https://codeforces.com/contest/1523/problem/D
n명의 친구와 함께 m개의 화폐에 대해 토론하려고 한다. i번 친구가 j번 화폐를 좋아하는 지 여부를 알고 있을 때, 절반 이상의 친구가 좋아하는 화폐 subset의 최대 크기를 구해야 한다. n의 최대값은 20만이며, m의 최대값은 60이다. 단, 어떤 친구가 좋아하는 화폐의 개수는 최대 15개이다. 후보 화폐의 개수가 많으므로 랜덤으로 친구 1명을 고른다. 선택 받은 친구가 정답 subset을 싫어할 확률은 1/2이다. 따라서 t번 동안 랜덤으로 고른 친구가 좋아하는 화폐들로만 subset을 구성했을 때, 정답 subset을 구하지 못할 확률은 1/(2^t)로 매우 적다. 현재 고른 친구의 번호를 idx라고 하자. 그리고 idx 친구가 좋아하는 화폐들만을 사용해서 bitmask를 만든다. cnt[msk]는 정확히 msk 화폐들만을 좋아하는 친구의 수다. dp[smsk]는 smsk 화폐들을 좋아하는 친구의 수이다. dp[smsk]는 smsk를 서브 마스크로 하는 모든 msk에 대해, cnt[msk]의 합과 같다. msk의 비트 개수가 p일 때, (msk, smsk)의 쌍의 개수는 O(3^p)이다. 그 이유는 각각의 비트에 대해 다음 3가지 경우의 수만이 존재하기 때문이다. 첫 번째는 msk와 smsk 모두 꺼져 있는 경우, 두 번째는 msk에서 켜져 있지만 smsk에서는 꺼져 있는 경우, 마지막으로 msk와 smsk 모두 꺼져있는 경우이다. dp[smsk]를 모두 구했다면, ceil(n/2) 값보다 큰 dp[smsk]에 대해 켜져 있는 비트가 가장 많은 smsk를 구해주면 된다. 총 시간 복잡도는 O(t * (3^p + n*p))이다.

idx 친구를 랜덤으로 정할 때, 생각 없이 rand() 함수를 써서 WA를 받았다. rand() 함수의 반환 값은 최대 32000 정도이기 때문에, 20만 명의 친구 중에 1명을 랜덤으로 선택하기엔 그 범위가 너무 작다. 따라서 rand() * 30000 + rand() 과 같은 연산을 통해, 더 큰 범위에 대한 랜덤한 값을 구해야한다.

2021-06-10
https://codeforces.com/contest/1515/problem/E
n개의 컴퓨터가 일렬로 나열되어 있다. 우리는 n개의 컴퓨터를 모두 켜려고 한다. 어떤 시점에 i-1 컴퓨터와 i+1 컴퓨터가 켜져있다면 i번 컴퓨터는 자동으로 켜진다. 그리고 어떤 컴퓨터가 켜지고 나면, 그 컴퓨터를 수동으로 켤 수 없다. 수동으로 전원을 켠 컴퓨터의 순서를 sequence로 나타냈을 때, 나타날 수 있는 sequence의 경우의 수를 출력해야 한다. 문제를 풀기 위해서, 먼저 k개의 컴퓨터를 전부 수동으로 켜는 방법의 수를 계산해보자. 맨 처음 i번째 컴퓨터를 켠 이후로는 켜져있는 컴퓨터들은 모두 연속하여 배치되어 있어야 한다. 이 방식으로 계산할 경우 k-1C0 + k-1C1 + ... + k-1Ck-1 = 2^(k-1)이 된다. k개를 전부 수동으로 켜는 방법의 수를 귀납법을 이용해서도 계산할 수 있다. 1개의 컴퓨터를 켜는 방법의 수는 1가지이다. k-1개의 컴퓨터를 켜는 방법의 수가 x라고 했을 때, k개의 컴퓨터를 켜는 방법의 수는 2*x이다. 그 이유는 마지막으로 켠 컴퓨터는 1번 컴퓨터 또는 k번 컴퓨터이므로, k-1개 컴퓨터를 켜는 방법의 수에 정확히 2배가 되기 때문이다. 따라서 k개의 컴퓨터를 켜는 방법의 수는 2^(k-1)가지이다. 이 공식을 문제에 적용해보자. n개의 컴퓨터를 모두 켠 후 배열의 형태는 (수동으로 전원을 켠 컴퓨터 1개 이상), (자동으로 켜진 컴퓨터 1개), (수동으로 전원을 켠 컴퓨터 1개 이상), ... , (수동으로 전원을 켠 컴퓨터 1개 이상) 꼴이 된다. dp(len, cnt)를 len-1개의 컴퓨터를 켰을 때, cnt개의 컴퓨터만 수동으로 조작한 경우의 수라고 하자. 이 때, len번째 컴퓨터는 자동으로 켜지도록 놔둔다. 그러면 dp(len, cnt)는 추가적으로 수동으로 조작한 컴퓨터 개수 k에 대해 dp(len+k+1, cnt+k)로 전이 된다. 전이될 때 곱해지는 값은 k개의 순서를 정하는 방법의 수 2^(k-1)와, cnt개의 sequence와 k개의 sequence가 순서의 변화 없이 섞이는 방법의 수 (cnt+k)C(k)이다. n개의 컴퓨터를 켜는 방법의 수를 계산하기 위해서는 dp(n+1, cnt)의 값을 모두 더하면 된다.

2021-06-11
https://codeforces.com/contest/1481/problem/E
n개의 책이 일렬로 나열되어 있다. 각 책은 1~n 사이의 색상을 가지고 있다. 책의 순서를 바꾸어서 같은 색상의 모든 책들이 서로 인접하도록 만드려고 한다. 순서를 바꾸기 위해 할 수 있는 연산은, 임의의 책 1개를 골라 제일 오른쪽 끝으로 이동시키는 연산이다. 연산 횟수를 최소로 만들었을 때 연산 횟수를 구해야 한다. 이 문제를 가만히 놔둘 책의 개수 최대값을 구하는 문제로 변경할 수 있다. 문제를 풀기 위해 사용되는 값들을 정리해보면, l(c)는 c 색상의 책이 등장한 제일 왼쪽 인덱스이다. r(c)는 c 색상의 책이 등장한 제일 오른쪽의 인덱스이다. f(c) 는 c 색상의 책이 등장한 횟수이다. dp(i)는 [i, n] 구간에 가만히 놔둘 책의 개수 최대값을 의미한다. curf(c)는 현재 i에서 [i, n] 구간에 c 색상의 책이 등장한 횟수를 의미한다. dp(i)를 계산하기 위해서, i = l(a(i)) 일때는 dp(i) = f(a(i)) + dp( r(a(i)) + 1)로 전이된다. 현재 색상의 책 모두를 이동시키지 않고 놔두는 경우이다. 이 때, l(a(i))와 r(a(i)) 사이에 존재하는 a(i) 색이 아닌 모든 책들은 이동한다. i != l(a(i)) 일때는 dp(i) = curf(a(i))로 전이된다. [i, n] 구간에 등장한 현재 색상의 책 모두를 그대로 놔두고, 나머지 모든 책들은 이동시키는 경우이다. 이동하지 않은 a(i) 색상의 책들은 i 이전에 등장하는 같은 색의 책들과 합쳐지게된다. 마지막으로 현재 i번째 책을 제거하는 이동시키는 경우이다. 이 경우 dp(i) = dp(i+1)로 전이된다. dp(1)에는 [1, n] 구간에 대해 이동시키지 않을 책의 최대 개수가 저장되어 있다. 따라서 n - dp(1)이 우리가 구하고자하는 문제의 답이 된다.

2021-06-13
https://codeforces.com/contest/1455/problem/C
난이도가 *1100으로 책정될 만큼 쉬운 문제였지만 virtual 대회 중에 풀지 못 했다. A와 B가 탁구 게임을 진행한다. A가 선공이며, A와 B는 각각 x, y 스태미너를 가지고 있다. 공을 칠 때마다 1 스태미너가 소비되며, 둘 모두 스태미너가 떨어지면 게임은 종료된다. 첫 게임에서 서브는 A이며, 두번째 게임부터는 이전 게임의 승자가 서브를 한다. 서브 차례에선 반드시 공을 쳐야하지만, 그 이후부터는 공을 치지 않고 스태미너를 아낄 수 있다. A, B 둘 다 자신의 승리 횟수는 최대로 하고, 상대의 승리 횟수는 최소로 하는 전략을 취할 때, 게임이 종료된 후 A, B의 승리 횟수를 출력해야 한다. A는 선공이며, 반드시 공을 쳐야하기 때문에 당장은 선택권이 없다. B는 승리 수를 최대로 하기 위해, A가 스태미너를 모두 소비할 때까지 공을 치지 않는다. 이후 B는 모든 스태미너를 소비하여 y 승리 포인트를 획득할 수 있다. 이 때, A의 마지막 공을 B가 받아칠 수 있다. 이 경우, B의 승리 횟수를 줄이지 않고 A 승리 횟수를 줄일 수 있기 때문에 B는 무조건 공을 받아 칠 것이다. 따라서 A, B의 최종 승리 횟수는 x-1, y이다. 그리디, 특히 게임 이론 문제에서 많이 약하다. 게임 이론 문제야 말로 다양한 접근이 필요한 문제인데, 하나의 솔루션에 빠져서 헤어나오지 못할 때가 많은 것 같다.

2021-06-14
https://codeforces.com/contest/1452/problem/E
n개의 문제와 m개의 참가자가 있다. 2명의 출제자가 각각 k개의 연속적인 문제에 대해 해설을 작성하려고 한다. i번째 참가자가 관심을 가지는 문제 구간 [l(i), r(i)]이 주어지고, a(i)가 두 명의 출제자가 작성한 해설 중 겹치는 문제가 가장 많은 쪽의 겹치는 문제 수일 때, a(i)의 합을 최대화하려고 한다. 두 출제자들이 최적의 k개를 선택했을 때, a(i) 합의 최대값을 구해보자. l(i), r(i)를 하나의 세그먼트로 나타냈을 때, [l(i)-1, r(i)]를 중심 좌표 순으로 정렬하자. 이 때, 앞쪽의 세그먼트 i개는 첫번째 작가가 맡고, 뒤쪽의 세그먼트 m-i개는 두번째 작가가 맡으면 최적이다. 그 이유는 2개의 세그먼트에 대해, 두 중심 좌표가 가까우면 가까울 수록 겹치는 부분도 많아지며, 그 증가와 감소가 대칭을 이루기 때문이다. pre(i)를 1번 출제자가 [0, i] 세그먼트를 맡았을 때, [0, i] 세그먼트 들의 최대 a(i) 합이라고 하자. 그리고 suf(i)를 2번 출제자가 [i, m-1] 세그먼트를 맡았을 때, [i, m-1] 세그먼트들의 최대 a(i) 합이라고 하자. 그러면 i = 0~m-1에 대해 pre(i) + suf(i+1) 합의 최대값이 문제의 답이 된다. pre(i)를 구하기 위해서 출제자 세그먼트 1개를 임의의 위치에 고정시킨다. 그 후, 현재 위치 [al, ar]에서 [0, i] 세그먼트 들의 a(i) 합을 구한다. i를 1씩 증가시키면서 a(i)을 구할 경우 O(M)만에 모두 계산할 수 있으며, 출제자 세그먼트의 위치 경우의 수는 O(N)이므로 총 시간복잡도 O(NM)만에 pre(i)를 계산할 수 있다. 같은 방식으로 suf(i) 역시 계산해준 뒤 정답을 출력해준다.

2021-06-21
SCPC-1 예선-1 4번
임의의 좌표에 배터리를 뒀을 때, 모든 선분의 양 끝 점 중 Chebyshev 거리 중 최소값 중 최대값을 최소화하여 그 값을 출력해야 한다. 선분의 개수는 최대 100개이다. 문제를 조금 다르게 모델링하면, 모든 선분들에 대해 하나 이상의 끝점을 포함하는 최소 크기의 정사각형을 구하면 된다. 문제를 풀기 위해서는 정사각형의 크기에 대해 이분탐색을 수행해주면 된다. 정사각형의 위치 역시 중요한데, 조건을 만족하는 정사각형 중에는 반드시 왼쪽 아래 꼭지점 x좌표는 내부의 점들 중 하나의 x좌표와 같고, y좌표 역시 내부의 점들 중 하나의 y좌표와 같다. 왜냐하면 그렇지 않은 정사각형을 크기의 변화 없이 내부의 점들의 x, y좌표와 일치시킬 수 있기 때문이다. 따라서 모든 가능한 좌표에 대해 이분탐색을 수행하면 쉽게 문제를 해결할 수 있다. kdh는 조금 다르게 좌표 압축 후 2차원 부분합을 이용하여 문제를 풀었다. 현재 탐색 중인 Chebyshev 거리 값이 len일 때, 압축된 O(N^2)공간에서 각 셀에 대하여, 현재 셀에 배터리를 설치했을 때 len 거리 이내에 있는 선분의 개수를 O(N^2)만에 구해낼 수 있다. 2D 부분합을 복습하자면 구간 쿼리마다 O(1)개의 값의 변화량을 표시해두면, 마지막에 O(N^2)의 연산 만에 쿼리 결과를 구할 수 있다.

SCPC-1 예선-1 5번
N개의 정점, M개의 무방향 간선이 있는 그래프가 주어졌을 때, 임의의 두 정점 쌍에 대해 차량은 두 정점 쌍 간의 최단경로로만 움직인다. 이 때, 중간 경로로 절대 사용되지 않는 정점을 모두 구해야 한다. 다익스트라를 모든 시작점에 대해 돌려준 뒤, 사용되지 않은 정점을 출력해주면 된다. 풀이를 보면서 알게된 다익스트라의 특징 중 하나는, 어떤 간선이 무방향 간선이라면 그 간선은 한 방향으로만 이용되거나 아예 이용되지 않는다는 것이다.

2021-06-22
SCPC-1 예선-2 2번
a, b가 번갈아가며 돌을 a~ak개, b~bk개 가져갈 수 있을 때, n번째 돌을 가져가면 패배하는 게임을 하려고 한다. a, b 둘다 이기기 위한 최선의 전략을 취할 때 게임의 결과를 출력해야 한다. 게임이론을 이용한 문제이다. 복습하자면, 승리 상태는 상대를 패배 상태로 만들 수 있는 상태이며, 패배 상태는 상대를 승리 상태로 밖에 만들 수 없는 상태를 의미한다. 상대를 패배 상태로 만들 수 있는지 확인하기 위해서는 dp테이블의 부분합을 매번 갱신해주면 된다. 현재 상태에서 만들 수 있는 다음 상태는 연속된 구간으로 나타나기 때문에 O(1)만에 승리 상태인지 패배 상태인지 판단할 수 있다.

SCPC-1 예선-2 3번
비교적 쉬운 dp문제. 하지만 dp table을 INF로 초기화하는 과정에서 실수를 하여 부분점수를 받았다. i의 범위는 0부터 n까지이고, j의 범위는 0부터 m까지인데, 둘다 0부터 n까지 초기화하는 바람에 dp table 일부가 초기화되지 않은 것이다. 작은 실수로 인해 많은 시간이 소모될 수 있으니 꼼꼼히 확인하자.

SCPC-1 예선-2 4번
최대 10만개의 폐구간이 주어졌을 때, 완전 중첩된 부분집합 중 원소의 개수가 가장 많은 것을 찾고, 그 개수를 출력해야한다. 이 때 완전 중첩된 부분집합이란, 부분집합에 속한 임의의 두 폐구간이 서로 포함관계를 만족하는 부분집합을 말한다. 세그먼트 트리를 사용하면 문제를 해결할 수 있다. 폐구간 [l, r]을 r좌표 순, l좌표 역순으로 정렬한 뒤, 순서대로 계산한다. r좌표 순으로 먼저 정렬했기 때문에, 이전의 구간들 중 l좌표가 현재 구간보다 크거나 같은 구간들은 모두 현재 구간에 포함된다. 각 구간으로 끝나는 완전 중첩 부분집합의 최대 크기를 세그트리 l 인덱스에 누적 저장하자. 그러면 현재 구간에서 끝나는 완전 중첩 부분집합의 최대 크기는 세그트리 쿼리 [l, r] 결과에 1을 더해서 구할 수 있다. kdh 풀이 슬라이드에서는 문제를 "전체 구간들을 시작점 내림차순으로 정렬하고 나면, 거기서 끝점이 단조 증가하는 구간들을 최대한 많이 고르는 문제"라고 표현했다. 그리고 실제로도 LIS를 이용해서 문제를 해결했다. 이 방법이 구현도 훨씬 쉽다.

SCPC-1 예선-2 5번
최대 500개의 대학, 최대 5000개의 무방향 간선으로 이루어진 그래프가 주어진다. 주어진 그래프에서 임의의 두 정점 간의 최단경로로 반드시 사용되는 정점을 모두 출력해야한다. 문제를 풀기 위해서 모든 정점을 시작점으로 하여 다익스트라를 n번 실행한다. 각 실행마다 pv(i)를 빌드해주는데, pv(i)에는 i번 정점에 최단 경로로 도달하기 직전의 정점의 목록을 의미한다. 이후 pv(i)의 크기가 1이며, pv(i)에 담긴 정점이 p일때, p가 시작 정점이 아니라면 p는 우리가 찾고자하는 정점 중 하나가 된다.

2021-06-28
SCPC-2 예선-1 1번
답의 범위가 long long 범위를 넘어서기 때문에 unsigned long long을 써야했다. 그런데 출력할 때 %llu가 아닌 %lld를 사용해서 계속 오답을 받았다. 덤으로 1LL 대신에 1UL을 쓰면 상수를 unsigned long long 형으로 취급할 수 있다.

SCPC-2 예선-1 2번
징검다리의 개수 n과, 한번에 최대한 이동할 수 있는 거리 k가 주어졌을 때, n번째 징검다리까지 도달하는 경우의 수를 계산해야한다. 이 때, 몇몇의 징검다리에는 지뢰가 설치되어 있어 밟지 못한다. dp[i][j]를 i번째 징검다리에 도달했고, 마지막 점프가 j길이인 경우의 수라고 하자. 그러면 dp table을 O(n*k*k)만에 계산할 수 있다. 하지만 이 방식으로는 TLE를 받게된다. dp table을 잘 살펴보면 dp[i][j]에서 dp[i+jump][jump]로 전이될 때, dp[i][*]의 값 중 dp[i][jump]만 제외된다. 따라서 dp[i][*]의 합을 미리 구해두면, 그 값에서 dp[i][jump]만 빼면 되므로 dp[i][*]에서의 전이를 O(k)만에 할 수 있다. 이 때 총 시간복잡도는 O(n*k)이다. MOD로 사용되는 값이 1e9+7이 아닌 1e9+9였는데, 이를 확인하지 못 해 오답을 여러번 받았다.

https://www.acmicpc.net/problem/2311
N개의 도시가 있고 M개의 간선이 있을 때, 1번 도시에서 N번 도시로 갔다가 다시 1번 도시로 돌아오는 최단 거리를 구해야한다. 단, 한번 이용한 간선은 다시 이용할 수 없다. 소스, 싱크와 연결된 간선의 용량은 2로 두고, 그 외의 간선의 용량을 1로 둔 뒤 MCMF를 수행하면, 간선을 1번씩만 이용하는 최단 경로를 구할 수 있다.

https://www.acmicpc.net/problem/3938
똑같은 2개의 방이 있고, 그 중 하나의 방을 이용하고 싶어하는 최대 1000명의 고객이 있다. 각 고객은 [i, j] 기간 동안 방을 이용하고 싶어하고 w의 비용을 지불하려고 한다. i, j의 범위는 1이상 365이하이다. 최적의 방법으로 방을 배정했을 때 얻을 수 있는 최대 비용을 구해야한다. MCMF를 이용하여 문제를 해결할 수 있다. MCMF의 경우 최대 유량을 최소 비용으로 흐르게 만드는데, 비용을 -로 만들면 최대 유량을 최대 비용으로 흐르게 만들 수 있다. 내가 문제를 풀 때는 각 일정마다 IN, OUT 정점을 만들어서 IN에서 OUT으로 가는 간선의 비용을 음수로 지정하고, 각 일정마다 다음으로 올 수 있는 일정으로 간선을 만들어서 MCMF를 적용했다. 이 때, 만들어지는 간선의 개수는 O(N^2)개이다. 정해는 좀 더 빠르게 동작한다. 먼저 1일부터 365일까지, 그리고 365일에서 366일까지 용량 2, 비용 0인 간선을 연결한다. 그리고 각 고객마다 i에서 j+1로 연결되는 용량 1, 비용 -w인 간선을 연결한다. 그 후 MCMF를 적용하면 원하는 답을 훨씬 빠르게 구해낼 수 있다.

2021-06-29
SCPC-2 예선-1 3번
n개의 정점과 m개의 간선으로 이루어진 그래프가 주어진다. n의 값은 최대 100이다. 정점을 0개 이상 제거해서 각 정점이 k개 이상의 이웃을 가지고, 이웃을 제외한 다른 정점의 개수가 l개 이상이 되도록 만드려고 한다. 제거한 정점의 개수를 최소로 할 때, 지운 정점의 번호의 총합의 최소값을 구해야 한다. 차수가 k 미만이 된 정점은 반드시 지워야한다. 이후에 어떤 작업을 하더라도 지워지도록 되어있다. 마찬가지로 이웃이 아닌 정점이 l 미만인 정점 또한 반드시 지워야한다. 따라서 단순히 조건을 만족하지 않는 정점을 찾고 지우는 작업을 반복하면 된다. 최종 상태가 마치 유일하지 않은 것처럼 문제에서 표현했으나, 사실 최종 상태는 유일하다. kdh 풀이에 그 증명이 적혀져 있다. 가장 적은 정점을 없애면서 조건을 만족시킨 최종상태가 2개 있다고 가정하고, 각각에 대해 남은 정점의 집합을 A, B라고 하자. A != B 이므로 lAUBl > max(lAl, lBl)이다. 또한 AUB에 속한 정점은 A(또는 B)에서 이미 조건을 만족하므로 정점이 추가되었을 뿐인 AUB에서도 역시 조건을 만족한다. 따라서 AUB 역시 조건을 만족시키는 집합이므로, A나 B보다 더 적은 정점을 없애면서 조건을 만족하는 최종 상태가 되므로 가정에 모순이다.

SCPC-2 예선-1 4번
n개의 정점과 m개의 간선으로 이루어진 그래프가 주어진다. 그리고 k개의 대피소 위치가 주어진다. 각 정점마다 가장 가까운 대피소까지의 거리와, 그러한 대피소들 중 정점 번호의 최소값을 구해야한다. N의 값은 최대 10만이며, M의 값은 최대 50만이므로 다익스트라를 여러번 수행하기는 힘들다. 대신에 모든 대피소들을 출발점으로 하는 다익스트라를 1번 수행하면 문제를 해결할 수 있다. 또는 가상의 노드를 시작점으로 하고, 시작점에서 각 대피소까지의 거리를 0으로 설정하면 1개의 시작점을 가지는 다익스트라를 수행할 수 있다. 그리고 거리값을 make_pair(dist, from)으로 설정하면, 거리가 같은 대피소들 중 제일 작은 정점 번호를 구할 수 있다. 내가 문제를 풀 때 우선순위 큐의 정렬 순서를 (가중치 합, 대피소 정점 번호) 순으로 지정했다. 그렇게 함으로써 각 정점에서 가장 가까운 대피소들 중 번호가 가장 작은 것을 구할 수 있을 거라고 생각했다. 하지만 어떤 정점까지의 최단 경로들 중, 바로 직전의 정점의 거리가 몇이냐에 따라서 갱신 순서가 달라질 수 있다. 따라서 내 풀이는 가장 가까운 대피소까지의 거리는 구해낼 수 있으나, 그러한 대피소 번호 중 최소값은 구해내지 못 했다. 그리고 문제를 풀 때 더 헤매게된 이유 중 하나는, 이러한 풀이를 사용하고도 부분점수를 받았다는 것이다. 나는 부분 점수를 받았으니 당연히 overflow 문제라고 생각하고 overflow가 날 것 같은 부분만 점검했지만, 사실은 풀이 자체에 문제가 있었다. SCPC의 채점 데이터를 너무 신뢰하지는 말아야겠다.

https://www.acmicpc.net/problem/8992
가로 세로 선이 주어졌을 때, 픽업 게임을 하려고 한다. 가로, 세로 선분의 교점을 클릭하면 두 선분의 무게를 곱한 값만큼 점수를 얻을 수 있다. 그리고 그 두 선분은 사라진다. 게임의 첫 번째 목표는 최대한 많은 선분을 집어가는 것이며, 두 번째 목표는 최대한 많은 점수를 얻는 것이다. MCMF로 문제를 해결할 수 있다. 가로 선분의 IN 정점에는 소스를 연결하고, 세로 선분의 OUT 정점에는 싱크를 연결한다. 각각의 선분들은 1번씩 사용되어야 하므로 IN 정점과 OUT 정점 사이에 용량을 1로 설정해둔다. N*M의 관계에서 두 선분이 한 점에서 만날 경우 가로 선분의 OUT 정점과 세로 선분의 IN 정점을 연결한다. 이 때 비용은 -wh*wv가 된다. MCMF는 최소 비용을 계산하므로 모든 간선의 비용을 음수로 바꾸어주면 최대 비용을 계산할 수 있다.

https://www.acmicpc.net/problem/9413
방향이 있는 그래프가 주어졌을 때, 서로 겹치지 정점이 겹치지 않는 2개의 경로를 만들어야 한다. 이 때, 두 경로에 포함된 정점의 개수를 최대로 해야 한다. MCMF로 문제를 해결할 수 있다. 각 정점의 IN 정점과 OUT 정점 사이에는 용량이 1이고, 비용이 -1인 간선을 연결한다. 두 경로의 시작지점은 임의로 정해야하기 때문에 소스에서 모든 정점의 IN 정점으로 간선을 연결해야 하고, 마찬가지로 모든 정점의 OUT 정점에서 싱크 정점으로 간선을 연결해야 한다. 만들 경로의 개수는 2개이므로, 싱크에서 최종 싱크까지 용량이 2인 간선을 연결하여 2를 초과하는 유량이 흐르지 않도록 한다.

2021-06-30
SCPC-2 예선-1 5번
n개의 구두 주문이 들어와 있고 장인이 k명 있을 때, n개의 구두를 모두 만들 수 있는지 판단해야한다. 각 구두마다 작업을 시작할 수 있는 시간 a, 작업을 마감해야 하는 시간 f, 필요 작업 시간 p가 정해져 있다. 그리고 각 장인마다 작업을 할 수 있는 시간 s, e가 정해져 있다. 특정 시간에 한 장인이 둘 이상의 구두에 작업할 수 없고, 한 구두에 둘 이상의 장인이 작업할 수 없다. 문제를 풀기 위해서는 네트워크 플로우를 사용해야한다. 소스에서 각 구두의 정점으로 p만큼의 용량을 가지는 간선이 연결되어 있고, 각 구두 정점에서 시간 정점 [a, f)으로 1의 용량을 가지는 간선이 연결되어 있다. 시간 정점에서 싱크로 가는 정점은 해당 시간에 작업할 수 있는 장인의 수만큼 용량을 가진다. 장인이 누구냐는 중요하지 않다.  이 문제를 풀기 위해 그리디를 적용하면 틀린다. 한 구두에 동시에 여러 장인이 작업할 수 없다는 조건 때문이다.

https://www.acmicpc.net/problem/9513
여러 개의 base part로 구성된 조립식 키트로 A class 배 a개, B class 배 b개를 만드려고 한다. 하나의 키트로는 하나의 배만 만들 수 있으며, 키트에 있는 base part 하나를 배의 재료 중 하나로 바꾸어 배를 만들 수 있다. base part i를 배 재료 j로 바꾸는 데 드는 비용이 주어지고, 만들어야 할 A class 배의 개수와 B class 배의 개수, 그리고 A class, B class 배 하나를 만드는 데 필요한 각 재료의 개수가 주어졌을 때, 모든 배를 만드는 데 필요한 최소 비용을 구해야 한다. a + b개의 키트가 사용될 텐데, 각 키트의 구성은 모두 동일해야한다. MCMF로 문제를 해결할 수 있다. 키트의 구성이 정해졌을 때, 같은 class인 두 개의 배는 항상 같은 방법으로 재료를 만들어낸다. 따라서 flow의 총량을 A class 배를 만드는 데 필요한 재료의 총합 asum(= bsum)으로 하고, 비용에 a(b)를 곱해주면 키트의 구성을 모두 동일하게 만들면서 문제를 해결할 수 있다. 그래프의 흐름은 A 재료, base part, B 재료 순서이다. A에 사용된 재료를 base part로 바꾸는 데 비용이 들고, 그 base part를 다시 B에 사용된 재료로 바꾼다. 만약 순서를 base part, A 재료, B 재료로 한다면, 임의의 A 재료가 어떤 base part로 만들어졌는지 모르기에 간선을 연결하기 어렵다. 또 다른 방법으로 순서를 base part, (A 재료 + B 재료)로 한다면, base part로 들어갔던 유량이 A재료, B 재료로 나눠져 들어가야하는데, asum(= bsum)보다 많은 양의 유량이 흐르게 되므로 A class에 사용된 키트와 B class에 사용된 키트의 구성이 달라질 수 있다. 매칭과 관련된 문제는 각 그룹을 병렬이 아닌 직렬로 배치하는 경우가 많은 것 같다.

SCPC-2 예선-2 3번
철광석 광산과 구리 광산이 좌표 평면 위에 분포되어 있다. 광산의 개수는 최대 10만개일 때, 좌표 평면 위 임의의 점 p를 기준으로 평면을 4등분 하려고 한다. 4등분한 뒤, 북서쪽 평면과 남동쪽 평면은 철광석 광산만, 북동쪽 평면과 남서쪽 평면은 구리 광산만 취하려고 할 때, 그 광산 개수의 최대값을 구해야한다. 문제를 보고 세그먼트 트리 스위핑일 거라고 예상하고 접근했다. 가로선 없이 세로선 만으로 구역을 나눈다고 하자. psum1[i]를 [0~i] 구간에 있는 철광석 광산의 개수라고 하고, psum0[i]를 [i~mx) 구간에 있는 구리 광산의 개수라고 했을 때, psum1[i] + psum0[i+1] 중 최대값이 문제의 답이 된다. 이 값들을 세그먼트 트리에 업데이트 한다. 저장된 값을 tree[i]라고 하자. 가로선을 바닥에서부터 조금씩 올리면 광산의 y좌표 순으로 그 종류가 바뀐다고 볼 수 있다. 철 광산이었던 점은 구리 광산으로 계산해주면 되고, 구리 광산이었던 점은 철 광산으로 계산해주면 되는 식이다. i 좌표 위의 한 점이 변경되면 psum1[i+1 ~ mx)의 값이 1 증가하거나 감소하고, psum0[0~i]의 값이 1 감소하거나 증가한다. 그에 따라 tree[i+1~mx)의 값은 1 증가하거나 감소하고 tree[0~i]의 값은 1 감소하거나 증가한다. 구간 업데이트 연산은 레이지 프로퍼게이션 기능을 가진 세그먼트 트리를 사용하면 O(logN)만에 계산할 수 있다. 하지만 TLE를 받았다. 정해는 구간 업데이트가 필요없는 세그먼트 트리 풀이였고, 그 마저도 아슬아슬하게 통과하기 때문에 구간 업데이트를 사용한 풀이는 TLE를 면하기 어려웠다. 정해는 이렇다. 세그먼트 트리에는 3가지 값을 저장한다. tree1[no]는 구간 내 1(철광석)의 개수를 의미한다. tree0[no]는 구간 내 0(구리)의 개수를 의미한다. trmax[no]는 구간 내에서 임의의 기준 점을 잡았을 때 (왼쪽 1 개수) + (오른쪽 0 개수)의 최대값을 의미한다. kdh는 풀이를 설명하면서, 세그먼트 트리 문제를 풀 때는 분할 정복으로 문제를 어떻게 풀지 고민해보면 좋다고 한다. 문제를 풀면서 몇가지 실수를 했는데, 첫 번째는 lazy 세그먼트 트리를 사용할 때, 초기화 과정에서 lazy 값들을 초기화하지 않은 것이다. 두 번째는 세그먼트 트리를 새로 구현을 할 때, 배열의 크기를 MX * 4가 아닌 MX로 지정한 것이다. 이 때문에 WA를 여러번 받았으며, 디버깅하는데 몇 시간이 소요됐다.

2021-07-02
https://www.acmicpc.net/problem/10786
k개의 팀이 있는 음식 공급 업체에 n개의 주문이 들어왔다. 회사의 위치가 1이고, 음식 제공을 요청한 곳의 위치가 2 ~ n+1일 때, 각 팀은 j에서 j < i 인 i로만 이동할 수 있다. j에서 j+k로 이동하는 데 드는 비용 arr(j, k)가 주어졌을 때, n개의 주문을 모두 처리하는 데 드는 최소 비용을 구해야 한다. 단, k개의 팀이 모두 움직일 필요는 없다. MCMF를 사용하면 문제를 해결할 수 있다. k개의 팀이 모두 움직일 필요가 없으므로 k의 유량이 흐르도록 하면 안 된다. n개의 주문이 모두 처리가 되어야 하므로 n의 유량이 흘러야한다고 생각했다. 하지만 어떻게 해야 n개의 주문이 모두 처리가 되면서 그 비용을 계산할 수 있는지 생각해내지 못 했다. 정해는 이렇다. 문제의 조건을 만족시키기 위해서는 1번 다음에 올 수 있는 노드는 최대 k개이며, 각 j번 노드(2 <= j <= n+1) 이전에 올 수 있는 노드는 정확히 1개이다. 1번 노드로부터 k개의 팀이 출발하며, 그 외의 노드들은 1번만 방문해야하기 때문인 것 같다. 그래프로 모델링하면 왼쪽에는 2번부터 n+1까지의 정점이 있고, 오른쪽에는 1번부터 n+1까지의 정점이 있다. 왼쪽 노드 i에서 오른쪽 노드 j로 간선을 연결하는데, 이는 i번 노드 이전에 j번 노드를 방문한다는 뜻이다. 이 간선의 비용은 arr(j, i-j)가 된다. 이렇게 함으로써 2~n+1번 노드는 이전 노드로써 1번만 선택될 수 있고, 1번 노드는 이전 노드로써 k번 선택될 수 있다. 모든 주문 노드 들에게 이전 노드가 있다는 것은 모든 주문 노드들이 방문되었다는 것을 의미한다. MCMF를 적용하면 문제에서 요구하는 최소 비용을 계산할 수 있다. 

n이 10만 가까이 되면 MCMF로 못 푼다고 봐야 한다.

2021-07-03
SCPC-2 예선-2 5번
문제를 풀진 못 했지만 아이디어를 간략하게 써두려고 한다. n명의 난민이 있고, k개의 추가 보급품이 있다. 보급품의 종류는 물과 빵이다. 추가 보급품을 적절히 분배해서 각 난민의 불평등 지수 중 최대값을 최소화하려고 한다. 가상의 평균 난민 c를 정의했을 때, p 난민의 불평등 지수 u(p) = d(c, p) + e(p)이다. e(p)는 지급받은 추가 보급품 양이고, d(c, p)는 c난민과 p난민이 지급받은 물 양의 차이값과 빵 양의 차이값의 합이다. 수식으로 나타내면 d(c, p) = |x(c) - x(p)| + |y(c) - y(p)|이다. 각 난민의 x(p), y(p)를 좌표 평면상에 나타내면 n개의 점이 찍힌다. 추가 보급품이 없을 때, 불평등 지수를 최소화하는 것은 좌표 평면의 n개의 점을 모두 포함하는 최소 크기의 마름모를 구하는 것과 같다. 경계선의 좌표는 주어진 n개의 좌표 중 하나로 하여 parametric search로 구할 수 있다. 추가 보급품 배분이 정해져 있다면 점을 몇개 추가함으로써 불평등 지수 최대값의 최소값을 구할 수 있다. 각 점마다 추가 보급품 양이 k일 때, (x, y+k), (x, y-k)에 점을 찍는다. 이 때, 추가로 찍은 점을 모두 포함하는 최소 크기의 마름모를 계산하면 우리가 원하는 최소값을 구할 수 있다. 이 다음부터는 완전히 이해하지 못 했는데, 추가 보급품의 분배가 정해지지 않았을 때는 그리디를 적용할 수 있다고 한다. 마름모의 중심에 가까울 수록 많은 양의 보급품을 주는 것이 최적이다. 지금까지 설명한 대로 구현하면 총 시간복잡도는 O(N^3K^2logN)이 되는데, 약간의 커팅을 이용하면 좀더 빠르게 동작한다고 한다.

SCPC-2 본선 2번
n개의 집, m개의 쓰레기통이 있다. m개의 쓰레기통을 잘 배치해서, 각 집에서 가장 가까운 쓰레기통 까지의 거리의 합을 최소로 하려고 한다. dp를 이용해서 문제를 해결할 수 있다. 각 쓰레기통이 매칭된 집의 집합은 집을 좌표 순으로 정렬했을 때 연속적으로 나타났다. dp(i, j)를 i번 집까지 j개 쓰레기통을 설치했을 때 거리합의 최소값이라고 두자. 그러면 dp(i, j) = min(k=1~i) { dp(i-k, j-1) + minv(i-k+1, i) }가 된다. 이 때, minv(i, j)는 i번 집부터 j번 집까지 하나의 쓰레기통으로 매칭시킬 때 거리 합의 최소값이다. 총 시간 복잡도는 O(n^2m)이 된다. 그런데, 단순히 반복문을 이용하여 dp table을 모두 채우려고 하면 TLE를 받는다. memoization을 이용하면 사용되는 dp table은 절반으로 줄어드는데, 각 상태에서 이전 상태의 개수는 i에 비례하므로 4배 가까이 빨라지지 않을까 한다.

https://www.acmicpc.net/problem/15504
n명의 참가자가 있다. 각 참가자는 실력 a(i), 경기 1번 당 받는 피로도 h(i), 참가할 수 있는 경기 횟수 최대값 l(i)이 정해져 있다. 참가자들 끼리 1:1 대결을 n-1번 진행하려고 한다. 두 참가자가 1:1 대결을 진행할 경우 실력의 값이 높은 사람이 승리하게 되고, 진 쪽은 다음 대결에 참가할 수 없다. i번 참가자와 j번 참가자가 대결을 할 경우, 이 대결의 재미는 a(i) ^ a(j)가 되고, i번 참가자는 h(i)의 피로도, j번 참가자는 h(j)의 피로도를 받게 된다. 대회의 재미를 (모든 대결의 재미 합) - (모든 선수의 피로도 합)이라고 했을 때, 대회의 재미 최대값을 구해야한다. MCMF로 문제를 해결할 수 있다. n-1번의 대회가 진행되므로 flow의 값은 n-1이 되어야한다고 생각했다. 참가자들을 실력 순으로 정렬하면 n번을 제외한 참가자들은 정확히 1번만 패배한다. 이분 그래프의 매칭 문제로 모델링해보면 왼쪽에 있는 노드는 1번 참가자부터 n-1번 참가자들의 패배 노드가 되고, 오른쪽에 있는 노드는 1번 참가자부터 n번 참가자들의 승리 노드가 된다. 패배의 경우 1번씩만 할 수 있으므로 소스에서 패배 노드까지 1 용량을 가진 간선이 연결되고, 승리의 경우 n번 노드는 l(n)번, 그 외의 i번 노드는 l(i)-1번 할 수 있으므로 승리 노드에서 싱크 노드까지 해당 용량의 간선이 연결된다. 승리 노드와 패배 노드 사이에는 (a(i) ^ a(j)) - (h(i) + h(j))에 -1을 곱한 값의 비용을 가진 간선이 연결된다. -1을 곱한 이유는 MCMF가 최소 비용을 구하므로 -1을 곱함으로써 최대값을 구하기 위함이다.

2021-07-05
SCPC-2 본선 3번
최대 길이 5000인 문자열이 주어진다. 이 문자열을 최소 개수의 절로 나누어서, 각 절이 같은 부분 문자열로 시작하고 끝나도록 만드려고 한다. 이 때, 시작 부분 문자열과 끝 부분문자열이 겹쳐서는 안 된다. 이 문제를 dp로 해결할 수 있다. dp(i)를 str[1~i]로 만들 수 있는 최소 개수의 절이라고 하자. 그러면 j=i+1~n의 dp(j) 값들을 kmp를 사용하여 O(n)만에 계산해줄 수 있다. 문제에서는 시작 부분 문자열과 끝 부분 문자열이 겹쳐서는 안 된다고 했는데, 사실 겹치는 부분 문자열이 있다는 것은 겹치지 않는 부분 문자열도 존재한다는 뜻이다. 전이를 위해 고려중인 부분 문자열에서 마지막 kmp의 값이 1 이상이라면 하나의 절로 만들 수 있다. 총 시간 복잡도 O(n^2)만에 문제를 해결할 수 있다.

SCPC-2 본선 4번
가로 크기 n이 최대 10만, 세로 크기 m이 최대 10인 격자판이 주어진다. 그 위의 목표물 개수 p가 최대 1000일 때, 3x3 구역의 목표물을 파괴하는 폭격기를 보내서 모든 목표물을 파괴하려고 한다. 이 때 3x3 구역 내에 2개 이상의 목표물이 있어야 폭격기를 출격시킬 수 있다. 조건을 만족하면서 모든 목표물을 파괴할 수 있는 최소 폭격기 수를 구해야 한다. 3진수 bitmask dp를 사용하면 문제를 해결할 수 있다고 한다. 아직 만점을 받는 풀이를 이해하지 못 해서 부분 점수를 받은 풀이라도 작성해보려고 한다. 이 풀이 역시 3진수 bitmask dp를 사용한다. dp(mask, j)는 j까지 폭격기를 보내서 mask만큼의 목표물이 남았을 때 최소 폭격기의 수다. mask의 i 위치 값이 0일 경우 목표물이 이미 지워졌다는 뜻이며, 1일 경우 j열에 목표물이 남아있다는 뜻이고, 2일 경우 j-1열에 목표물이 남아있다는 뜻이다. 현재 상태 dp(mask, j)에서 dp(nmask, j+1)로 전이를 할텐데, j+1 열에 폭격기를 보낼 수 있는 모든 경우의 수를 시도했다. 가로 크기를 좌표 압축으로 O(p)로 줄이면, dp table의 크기는 O((3^m)p)이며, 현재 상태에서 다음 상태로 전이되는 경우의 수는 O(2^m)이므로 총 시간복잡도는 O((3^m)*p*(2^m))이 된다. 서브태스크1(p <= 20)에서는 약 12억이 나오고, 서브태스크2(m <= 6)에서는 약 4억이 나오는데, 커팅을 꼼꼼히 한 덕분인지 두 서브태스크를 모두 통과했다.

2021-07-06
n명의 직원이 있고, 각 직원들의 상하 관계가 트리 구조로 주어진다. 각 직원들은 기술 랭크를 가지고 있으며, 자신의 업무 결과를 기술 랭크가 자신보다 높은 상관 모두에게 검토받아야 한다. i번 직원의 업무 결과를 검토하는데 걸리는 시간 t(i)가 모두 주어졌을 때, 각 직원마다 부하 직원의 업무를 검토하는데 걸리는 총 시간을 구해야한다. 문제를 단순하게 설명하면 i번 서브트리 안에 랭크가 i보다 작은 노드들의 t(j) 합을 구하면 된다. 구간 합을 구하는 세그먼트 트리로 문제를 해결할 수 있다. 먼저 트리 상의 노드를 pre oreder로 번호를 매기면 i번 서브트리의 모든 노드들은 연속된 번호를 가지게 된다. i번 노드의 새로운 번호를 pos(i)라고 하고, i번 서브트리 내의 pos(j)중 가장 큰 값을 posmax(i)라고 하자. 이후 직원들을 랭크 순으로 정렬해서 답을 하나씩 구해낸다. 답을 구하기 위해 i번 직원보다 랭크가 낮은 직원들의 t(j)를 세그트리 상에 업데이트한다. 그 후 i번 서브트리에 해당하는 구간 [pos[i] ~ pos[j]] 내 t(i)합을 계산하면 우리가 구하고자 하는 답을 얻을 수 있다.

세그먼트 트리 문제는 변동하는 어떤 두 값의 쌍으로 이루어진 입력을 하나의 값을 기준으로 정렬한 뒤, 정렬된 순서대로 훑어보면서 다른 값을 인덱스로 사용하는 풀이가 자주 사용되는 것 같다.

2021-07-07
SCPC-3 예선-1 2번
최대 20만인 n 크기의 수열이 주어졌을 때, 증가 감소를 반복하는 가장 긴 부분 수열을 구해야 한다. 세그먼트 트리 풀이로 접근했으나 재귀를 사용하는 세그먼트 트리로는 TLE를 받았고, 반복문을 사용하는 세그먼트 트리로는 간신히 0.9초로 AC를 받았다. 정해는 O(N) 풀이였다. 구하고자 하는 부분 수열 중, 이전 항보다 값이 큰 항을 증가 항이라고 하고, 이전 항보다 값이 작은 항을 감소 항이라고 하자. 그러면 단순히 수열에서 비증가하다가 증가하기 직전의 항을 감소 항으로 고르고, 비감소하다가 감소하기 직전의 항을 증가 항으로 고르면 된다. 이와 같은 풀이가 가능한 이유는 i번째 항보다 i+1번째 항이 더 작거나 같다면, 감소 항으로써 i번째 항을 고르기보다 i+1번째 항을 고르는 편이 더 유리하기 때문이다. 증가 항을 고를 때도 마찬가지다. 구현할 때 좀 더 편하게 하려면, 인접한 두 항의 값이 같을 경우 하나의 항을 제거하는 게 좋다. 예제를 좀 더 만들어서 직접 풀어봤더라면, 규칙을 발견할 수 있지 않았을까.

2021-07-08
https://www.acmicpc.net/problem/14460
배열의 어떤 구간 내에 특정 숫자보다 큰 숫자의 개수를 계산할 수 있어야 한다. 머지소트트리를 금방 떠올릴 수 있었지만, 머지소트트리는 update 연산을 빠르게 해낼 수 없다. 대신에 이 문제에서는 조금 특별한 규칙이 있었다. 점 update가 필요하지만, 각 인덱스에 업데이트 되는 값은 정해져 있다는 것이다. 이 규칙을 이용해 각 인덱스에 업데이트 될 값들을 미리 머지소트트리에 넣어두고, 각 인덱스가 update 되었는지 여부를 펜윅 트리 또는 세그먼트 트리를 이용해서 관리한다. 즉, 각 index에 값을 update 하는 것 대신에 각 index를 활성화 시키는 것이다. 이렇게 구현하면 query에는 O(NlogN)의 시간이 걸리며, update에는 O(N (logN)^2)이 걸린다고 한다.

2021-07-09
https://www.acmicpc.net/problem/15018
처음에 n개의 카드를 가지고 있다. n개의 카드를 모두 판매할 건데, 매번 남은 카드 중에서 unique함이 가장 작은 카드를 골라 판매해야한다. 카드를 하나 판매할 때마다 남은 카드 중 최대 6개 카드의 unique함이 변한다. 따라서 unique함을 유동적으로 관리할 수 있어야하며, 그 중에서 최소값을 가진 카드를 빠르게 찾을 수 있어야 한다. set을 이용해서도 값들을 관리할 수 있지만, 세그먼트 트리를 연습중이라 세그먼트 트리로 문제를 해결했다. k번째 수를 찾는 것과 유사하게, 가장 작은 값을 가진 인덱스로 계속 파고 들면 된다.

2021-07-10
https://www.acmicpc.net/problem/17561
n개의 노드들은 각각 a, b, c 값을 가지고 있다. 임의의 i, j 노드에 대해 i의 a, b, c값 중 적어도 하나의 값이 j의 a, b, c, 값보다 크고, 그 외의 값들은 같다면 i번 노드는 useful 하지 않다고 이야기한다. n의 크기가 최대 10만일 때, useful한 노드의 개수를 계산해야 한다. 노드들을 a 비내림 차순으로 정렬한다. 먼저 현재 노드보다 작은 a 값을 가진 노드들을 세그먼트 트리에 업데이트 한다. 이 때, 세그먼트 트리의 b 위치에 c값을 업데이트 한다. 세그먼트 트리에 들어가 있는 노드들은 모두 현재 노드보다 a값이 작다. 따라서 b, c 값은 같아도 되고, 작아도 된다. 따라서 세그트리 [0, b+1) 구간의 최소값이 c 이하라면 현재 노드는 useful하지 않다. 이제 현재 노드와 a값이 같은 노드들을 업데이트 한다. 이제는 b가 현재 노드보다 작은 경우를 확인할 것이다. a, c의 값은 현재 노드와 비교했을 때 같아도 되고, 작아도 되므로 세그먼트 트리에서 [0, b) 구간의 최소값이 c 이하인지 확인한다. 마지막으로 c가 현재 노드보다 작은 경우를 확인한다. a, b의 값은 현재 노드의 a, b와 비교했을 때 같아도 되고, 작아도 되므로 세그먼트 트리에서 [0, b+1) 구간의 최소값이 c 미만인지 확인한다. 세 가지 조건 모두를 통과한 노드는 useful한 노드이다. 마지막으로 useful 노드의 개수를 계산하여 출력한다.

2021-07-12
SCPC-3 예선-1 3번
n*m개의 전구가 주어진다(n과 m은 최대 100). 각 전구에는 정확히 2개의 스위치가 연결되어 있다. 전구의 상태는 켜짐과 꺼짐 두가지이며, 전구에 연결된 스위치가 조작될 경우 전구의 상태는 반전된다. 임의로 스위치를 조작하여 모든 전구를 켜진 상태로 만들 수 있는 지 판단하고, 가능하다면 조작한 스위치들을 출력해야한다. ICPC 본선에서 풀었던 문제와 상당히 유사한 문제여서 가우스 소거법을 먼저 생각했었다. 하지만 항의 개수(스위치의 개수)가 최대 10000개여서 조금 힘들어보였고, 가우스 소거법 역시 잘 떠오르지 않아 풀지 못 했다. 정해는 2-SAT였다. 한 전구에는 정확히 2개의 스위치가 연결되어 있기 때문에 각 스위치에 대해 2개의 절을 만들 수 있다. 현재 전구가 켜져 있다면 전구에 연결된 스위치 중 하나가 조작될 경우 다른 스위치 역시 조작되어야 하고, 하나가 조작되지 않았다면 다른 스위치 역시 조작되지 않아야 한다. 반대로 전구가 꺼져 있을 경우 스위치 하나가 조작되었다면 다른 스위치 하나는 조작되지 않아야하고, 하나가 조작되지 않았다면 다른 스위치는 조작되어야 한다. 이를 2-SAT로 나타내보자. 현재 전구에 연결된 첫 번째 스위치를 켜야하는 경우를 논리 변수 x1이라고 두고, 두 번째 스위치를 켜야하는 경우를 논리 변수 x2라고 두자. 현재 전구가 켜져 있을 경우 만들어지는 절은 (x1 v -x2)와 (-x1 v x2)이다. 현재 전구가 켜져 있지 않을 경우 만들어지는 절은 (x1 v x2)와 (-x1 v -x2)이다. 이와 같은 방식으로 n * m * 2개의 절을 만든 후, 2-SAT를 해결해주면 문제를 풀 수 있다.

https://www.acmicpc.net/problem/10849
다익스트라를 연습하기 위해 풀었던 문제. 최대 20000인 n개의 정점이 있고, 방문하고 싶은 최대 15인 p개 정점이 있을 때, 0번 정점에서 p개 정점을 모두 방문하고 다시 0번으로 돌아오는 최단 경로를 구해야한다. 단, 딱 1번만 택시를 이용하여 임의의 정점에서 다른 정점으로 t 시간만에 이동할 수 있다. 0번 정점과 방문하고 싶은 p개 정점을 spc 정점이라고 하자. spc 정점 외에 다른 정점들은 중간 다리 정도의 의미밖에 가지지 않는다. spc 정점들을 시작점으로 하여 다익스트라를 p+1번 수행한다. 그러면 spc 정점간의 최단거리를 구할 수 있다. 이를 인접 배열로 저장한다. 그 후 bitmask dp를 수행한다. dp(mask, last, used)는 0번에서 출발하여 mask 정점들을 방문하고, 마지막에 last 정점을 방문했고, 택시 사용 여부가 used인 경우 최단 거리이다. dp table을 모두 완성하고 난 뒤, 택시를 이용하지 않았을 때 최단 거리, 택시를 이용했을 때 최단거리를 구할 수 있다. 이 값들을 토대로 g 시간 이내에 spc 정점들을 모두 방문할 수 있는지, 그리고 택시를 이용해야하는지를 판단해주면 된다.

2021-07-13
https://www.acmicpc.net/problem/16156
n*m 격자판이 주어진다. 그리고 각 위치로 이동하는데 걸리는 시간이 주어진다. 총 n명의 주자가 있고, i번 주자는 (i, 1)에서 출발하여 최단 거리로 m열까지 이동하려고 한다. 각 주자마다 최단 거리인 m열 위의 도착 지점이 유일할 때, (i, m)에 도달하는 학생의 수를 모두 계산해야 한다. 다익스트라를 이용하여 문제를 해결할 수 있다. 시작점이 2개 이상인 다익스트라를 돌릴 때, pq에 들어가는 노드에 출처를 적어두면 각 정점까지 최단 거리로 도달하기 위한 시작점을 쉽게 구할 수 있다. 내가 처음 문제를 풀 때는 다익스트라에 사용된 경로들이 DAG를 이룬다는 점을 이용하여, 다익스트라 후 dfs를 돌려서 답을 계산했다. 

2021-07-14
SCPC-3 예선-1 5번
트리 그래프가 주어진다. 이때, 리프의 노드는 정확히 2n개인데, i번 노드와 i+n번 노드 중 1개만 고를 수 있다. 이와 같이 고른 n개의 리프를 모두 연결할 수 있도록 최소 개수의 간선을 선택한다. 이렇게 선택된 간선의 가중치 합이 최대가 되도록 해야한다. MCMF로 문제를 해결할 수 있다. 트리 간선에 해당하는 플로우 간선은 단방향이고, 용량이 1이어야 한다. 각 간선의 비용이 1번씩만 계산되어야 하기 때문이다. 소스에서 모든 트리 노드로 플로우 간선이 연결되어야 한다. 플로우 간선의 용량이 1이므로 루트에만 소스를 연결하면 tree가 아닌 path가 만들어지기 때문이다. 루트는 신중하게 정해야 한다. 루트를 지나지 않는 것이 최적인 선택지가 있을 수 있는데, 그럼에도 불구하고 최대 비용을 만족하기 위해 조건을 무시하는 간선들이 추가될 수 있기 때문이다. 따라서 루트를 무조건 지나는 정점으로 잡아야하는데, 1번 또는 n+1번 정점을 루트로 잡고 MCMF 1번씩 돌리면 된다. 1번을 루트로 잡은 경우는 답이 1번 노드를 선택해야하는 경우의 답을 계산할 수 있고, n+1번을 루트로 잡은 경우는 답이 n+1번 노드를 선택해야하는 경우의 답을 계산할 수 있다.

2021-07-20
https://www.acmicpc.net/problem/15024
주어진 그래프에서 가장 작은 싸이클을 찾아야 한다. 처음엔 단순히 dfs를 이용하면 O(n+m)만에 가장 작은 싸이클을 찾을 수 있을 거라고 생각했다. 하지만 방문 순서에 따라 체크하지 못하는 싸이클이 존재했다. 따라서 가장 작은 싸이클을 찾으려면 모든 정점 v에 대해 bfs를 한번씩 돌려서 v에서 v로 가는 최단 경로를 찾아야 한다. 이 방법을 사용하면 가장 작은 싸이클을 O(n * (n+m))만에 찾을 수 있다.
